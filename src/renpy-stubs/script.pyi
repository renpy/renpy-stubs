import hashlib
import io
import renpy
from renpy.ast import Node as Node, NodeName as NodeName, PyCode as PyCode, PyExpr as PyExpr
from renpy.compat.pickle import dumps as dumps, loads as loads
from typing import Any

type FileListType = list[tuple[str, str | None]]
script_version: int
BYTECODE_VERSION: int
RPYC_MAGIC: bytes
RPYC2_HEADER: bytes
OLD_BYTECODE_FILE: str
BYTECODE_FILE: str

class ScriptError(Exception): ...

class LabelNotFound(ScriptError, LookupError):
    name: NodeName
    def __init__(self, label: NodeName) -> None: ...
    def get_suggestion(self) -> str | None: ...

def collapse_stmts(stmts: list[Node]) -> list[Node]: ...

class Script:
    key: bytes | None
    namemap: dict[renpy.ast.Node | NodeName, renpy.ast.Node]
    all_stmts: list[Node]
    all_pycode: list[PyCode]
    all_pyexpr: list[PyExpr]
    need_analysis: list[Node]
    need_compress: list[Node]
    record_pycode: bool
    bytecode_oldcache: dict[tuple[int, int, str, str, bytes, int, int], bytes]
    bytecode_newcache: dict[tuple[int, int, str, str, bytes, int, int], bytes]
    bytecode_dirty: bool
    translator: renpy.translation.ScriptTranslator
    serial: int
    digest: hashlib._Hash
    loaded_rpy: bool
    backup_list: list[tuple[str, bytes]]
    duplicate_labels: list[str]
    initcode: list[tuple[int, renpy.ast.Node]]
    loaded_scripts: set[tuple[str, str | None]]
    load_languages: set[str]
    def __init__(self) -> None: ...
    def choose_backupdir(self) -> str | None: ...
    def make_backups(self) -> None: ...
    def classify_script_files(
        self, dirlist: list[tuple[str | None, str]], script_files: FileListType, module_files: FileListType
    ) -> None: ...
    script_files: FileListType
    common_script_files: FileListType
    module_files: FileListType
    def scan_script_files(self) -> None: ...
    def clean_script_files(self) -> None: ...
    def script_filter(self, fn: str, dir: str | None) -> bool: ...
    def sort_script_files(self) -> FileListType: ...
    def load_script(self) -> list[tuple[int, Node]]: ...
    def load_module(self, name: str) -> list[tuple[int, Node]]: ...
    def include_module(self, name: str) -> None: ...
    def assign_names(self, stmts: list[Node], fn: NodeName) -> None: ...
    def merge_names(self, old_stmts: list[Node], new_stmts: list[Node], used_names: set[NodeName]) -> None: ...
    def load_string(
        self, filename: str, filedata: str | None, linenumber: int = 1
    ) -> tuple[list[Node], list[tuple[int, Node]]] | tuple[None, None]: ...
    def finish_load(
        self, stmts: list[Node], initcode: list[tuple[int, Node]], check_names: bool = True, filename: str | None = None
    ) -> list[Node]: ...
    def write_rpyc_header(self, f: io.BufferedWriter) -> None: ...
    def write_rpyc_data(self, f: io.BufferedWriter, slot: int, data: bytes) -> None: ...
    def write_rpyc_md5(self, f: io.BufferedWriter, digest: bytes) -> None: ...
    def read_rpyc_data(self, f: io.BufferedReader, slot: int) -> bytes | None: ...
    def static_transforms(self, stmts: list[Node]) -> None: ...
    def load_file(self, dir: str | None, fn: str) -> tuple[dict[str, Any], list[None]] | tuple[None, None]: ...
    def load_appropriate_file(
        self, compiled: str, source_extensions: list[str], dir: str | None, fn: str, initcode: list[tuple[int, Node]]
    ) -> None: ...
    def init_bytecode(self) -> None: ...
    def update_bytecode(self) -> None: ...
    def save_bytecode(self) -> None: ...
    def lookup(self, label: NodeName | renpy.lexer.SubParse) -> Node: ...
    def has_label(self, label: NodeName | renpy.lexer.SubParse) -> bool: ...
    def lookup_or_none(self, label: NodeName | None) -> Node | None: ...
    def analyze(self) -> None: ...
    def compress(self) -> None: ...
    def report_duplicate_labels(self) -> None: ...
    def __del__(self) -> None: ...
