import renpy
import renpy.ast as ast
from renpy.lexer import (
    Lexer as Lexer,
    ParseError as ParseError,
    SubParse as SubParse,
    elide_filename as elide_filename,
    group_logical_lines as group_logical_lines,
    list_logical_lines as list_logical_lines,
    munge_filename as munge_filename,
    unelide_filename as unelide_filename,
)
from renpy.parameter import EMPTY_ARGUMENTS as EMPTY_ARGUMENTS, Parameter as Parameter
from typing import Callable, Sequence, overload

type ParseNodeFunction = Callable[[Lexer, ast.NodeLocation], ast.Node | Sequence[ast.Node]]
parse_errors: list[str]
deferred_parse_errors: dict[str, list[str]]

def parse_image_name(l: Lexer, string: bool = False, nodash: bool = False) -> tuple[str, ...]: ...
def parse_simple_expression_list(l: Lexer, image: bool = False) -> list[str]: ...
def parse_image_specifier(
    l: Lexer,
) -> tuple[tuple[str, ...], str | None, str | None, list[str], str | None, str | None, list[str]]: ...
def parse_with(l: Lexer, node: ast.Node) -> ast.Node | list[ast.Node]: ...
def parse_menu(stmtl: Lexer, loc: ast.NodeLocation, arguments: ast.ArgumentInfo | None) -> list[ast.Node]: ...
def parse_parameters(l: Lexer) -> renpy.parameter.Signature | None: ...
def parse_arguments(l: Lexer) -> renpy.parameter.ArgumentInfo | None: ...

class ParseTrie:
    default: ParseNodeFunction | None
    words: dict[str, ParseTrie]
    def __init__(self) -> None: ...
    def add(self, name: list[str], function: Callable) -> None: ...
    def parse(self, l: Lexer) -> ParseNodeFunction | None: ...

statements: ParseTrie

def statement(keywords: str) -> Callable[[ParseNodeFunction], ParseNodeFunction]: ...
def if_statement(l: Lexer, loc: ast.NodeLocation) -> ast.If: ...
def IF_statement(l: Lexer, loc: ast.NodeLocation) -> list[ast.Node]: ...
def while_statement(l: Lexer, loc: ast.NodeLocation) -> ast.While: ...
def pass_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Pass: ...
def menu_statement(l: Lexer, loc: ast.NodeLocation) -> list[ast.Node]: ...
def return_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Return: ...
def jump_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Jump: ...
def call_statement(l: Lexer, loc: ast.NodeLocation) -> list[ast.Node]: ...
def scene_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Node | list[ast.Node]: ...
def show_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Node | list[ast.Node]: ...
def show_layer_statement(l: Lexer, loc: ast.NodeLocation) -> ast.ShowLayer: ...
def camera_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Camera: ...
def hide_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Node | list[ast.Node]: ...
def with_statement(l: Lexer, loc: ast.NodeLocation) -> ast.With: ...
def image_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Node: ...
def define_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Define | ast.Init: ...
def default_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Default | ast.Init: ...
def transform_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Transform | ast.Init: ...
def one_line_python(l: Lexer, loc: ast.NodeLocation) -> ast.Python: ...
def python_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Python | ast.EarlyPython: ...
def label_statement(l: Lexer, loc: ast.NodeLocation, init: bool = False) -> ast.Label: ...
def init_offset_statement(l: Lexer, loc: ast.NodeLocation) -> list[ast.Node]: ...
def init_label_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Label: ...
def init_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Init: ...
def rpy_statement(l: Lexer, loc: ast.NodeLocation) -> list[ast.Node]: ...
def screen_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Screen | ast.Init: ...
def testcase_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Testcase: ...
def testsuite_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Testcase: ...
def translate_strings(init_loc: ast.NodeLocation, language: str | None, l: Lexer) -> Sequence[ast.Node] | ast.Init: ...

translate_none_files: set[str]

def translate_statement(l: Lexer, loc: ast.NodeLocation) -> Sequence[ast.Node] | ast.Init: ...
def style_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Style | ast.Init: ...
def rpy_python(l: Lexer, loc: ast.NodeLocation) -> list[ast.Node]: ...
@overload
def finish_say(
    l: Lexer,
    loc: ast.NodeLocation,
    who: str | None,
    what: None,
    attributes: tuple[str, ...] | None = None,
    temporary_attributes: tuple[str, ...] | None = None,
    interact: bool = True,
) -> None: ...
@overload
def finish_say(
    l: Lexer,
    loc: ast.NodeLocation,
    who: str | None,
    what: str,
    attributes: tuple[str, ...] | None = None,
    temporary_attributes: tuple[str, ...] | None = None,
    interact: bool = True,
) -> ast.Say: ...
@overload
def finish_say(
    l: Lexer,
    loc: ast.NodeLocation,
    who: str | None,
    what: list[str],
    attributes: tuple[str, ...] | None = None,
    temporary_attributes: tuple[str, ...] | None = None,
    interact: bool = True,
) -> list[ast.Say]: ...
def say_attributes(l: Lexer) -> tuple[str, ...] | None: ...
def say_statement(l: Lexer, loc: ast.NodeLocation) -> ast.Say | list[ast.Say]: ...
def parse_statement(l: Lexer) -> ast.Node | Sequence[ast.Node]: ...
def parse_block(l: Lexer) -> list[ast.Node]: ...
def parse(fn: str, filedata: str | None = None, linenumber: int = 1) -> list[ast.Node] | None: ...
def release_deferred_errors() -> None: ...
def get_parse_errors() -> list[str]: ...
def report_parse_errors() -> bool: ...
