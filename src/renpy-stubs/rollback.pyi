import renpy
from _typeshed import Incomplete as Incomplete
from renpy.object import Object as Object
from renpy.revertable import RevertableObject as RevertableObject
from typing import Any

type RollbackIdentifier = tuple[float, int]

class StoreDeleted:
    def __reduce__(self) -> str | tuple[Any, ...]: ...

deleted: Incomplete

class SlottedNoRollback: ...
class NoRollback(SlottedNoRollback): ...

class AlwaysRollback(renpy.revertable.RevertableObject):
    def __new__(cls, *args, **kwargs) -> Incomplete: ...

NOROLLBACK_TYPES: tuple[type, type, type, type, type]

def reached(obj: Incomplete, reachable: Incomplete, wait: Incomplete) -> None: ...
def reached_vars(store: Incomplete, reachable: Incomplete, wait: Incomplete) -> None: ...

generation: float
serial: int
rng: Incomplete

class Forward:
    name: Incomplete
    data: Incomplete
    fixed: Incomplete
    def __init__(self, name: Incomplete, data: Any, fixed: bool) -> None: ...

class Rollback(renpy.object.Object):
    __version__: int
    identifier: RollbackIdentifier
    not_greedy: bool
    checkpointing_suspended: bool
    fixed: bool
    context: Incomplete
    objects: Incomplete
    purged: bool
    random: list[float]
    forward: Incomplete
    stores: Incomplete
    delta_ebc: Incomplete
    retain_after_load: bool
    checkpoint: bool
    hard_checkpoint: bool
    def __init__(self) -> None: ...
    def after_upgrade(self, version: int) -> None: ...
    def purge_unreachable(self, reachable: Incomplete, wait: Incomplete) -> Incomplete: ...
    def rollback(self) -> None: ...
    def rollback_control(self) -> None: ...

class RollbackLog(renpy.object.Object):
    __version__: int
    nosave: Incomplete
    identifier_cache: dict[RollbackIdentifier, int]
    force_checkpoint: bool
    log: list[Rollback]
    current: Rollback | None
    mutated: Incomplete
    rollback_limit: int
    rollback_block: int
    checkpointing_suspended: bool
    forward: list[Forward]
    old_store: Incomplete
    rolled_forward: bool
    retain_after_load_flag: bool
    did_interaction: bool
    def __init__(self) -> None: ...
    def after_setstate(self) -> None: ...
    ever_been_changed: Incomplete
    def after_upgrade(self, version: int) -> None: ...
    def begin(self, force: bool = False) -> None: ...
    def replace_node(self, old: Incomplete, new: Incomplete) -> None: ...
    def complete(self, begin: bool = False) -> None: ...
    def get_roots(self) -> Incomplete: ...
    def purge_unreachable(self, roots: Incomplete, wait: Incomplete = None) -> None: ...
    def in_rollback(self) -> bool: ...
    def in_fixed_rollback(self) -> bool: ...
    def forward_info(self) -> Any | None: ...
    def checkpoint(self, data: Any | None = None, keep_rollback: bool = False, hard: bool = True) -> None: ...
    def suspend_checkpointing(self, flag: bool) -> None: ...
    def block(self, purge: bool = False) -> None: ...
    def retain_after_load(self) -> None: ...
    def fix_rollback(self) -> None: ...
    def can_rollback(self) -> bool: ...
    def load_failed(self) -> None: ...
    def rollback(
        self,
        checkpoints: int,
        force: bool = False,
        label: str | None = None,
        greedy: bool = True,
        on_load: bool = False,
        abnormal: bool = True,
        current_label: str | None = None,
    ) -> None: ...
    def freeze(self, wait: Incomplete = None) -> Incomplete: ...
    def discard_freeze(self) -> None: ...
    def unfreeze(self, roots: Incomplete, label: Incomplete = None) -> None: ...
    def build_identifier_cache(self) -> None: ...
    def get_identifier_checkpoints(self, identifier: RollbackIdentifier) -> int | None: ...
