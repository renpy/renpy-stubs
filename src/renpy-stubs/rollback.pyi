import renpy
from _typeshed import Incomplete as Incomplete
from renpy.object import Object as Object
from renpy.revertable import RevertableObject as RevertableObject
from typing import Any

class StoreDeleted:
    def __reduce__(self): ...

deleted: Incomplete

class SlottedNoRollback: ...
class NoRollback(SlottedNoRollback): ...

class AlwaysRollback(renpy.revertable.RevertableObject):
    def __new__(cls, *args, **kwargs): ...

NOROLLBACK_TYPES: tuple[type, type, type, type, type]

def reached(obj, reachable, wait) -> None: ...
def reached_vars(store, reachable, wait) -> None: ...

generation: Incomplete
serial: int
rng: Incomplete

class Forward:
    name: Incomplete
    data: Incomplete
    fixed: Incomplete
    def __init__(self, name, data: Any, fixed: bool) -> None: ...

class Rollback(renpy.object.Object):
    __version__: int
    identifier: Incomplete
    not_greedy: bool
    checkpointing_suspended: bool
    fixed: bool
    context: Incomplete
    objects: Incomplete
    purged: bool
    random: Incomplete
    forward: Incomplete
    stores: Incomplete
    delta_ebc: Incomplete
    retain_after_load: bool
    checkpoint: bool
    hard_checkpoint: bool
    def __init__(self) -> None: ...
    def after_upgrade(self, version: int) -> None: ...
    def purge_unreachable(self, reachable, wait): ...
    def rollback(self) -> None: ...
    def rollback_control(self) -> None: ...

class RollbackLog(renpy.object.Object):
    __version__: int
    nosave: Incomplete
    identifier_cache: Incomplete
    force_checkpoint: bool
    log: Incomplete
    current: Incomplete
    mutated: Incomplete
    rollback_limit: int
    rollback_block: int
    checkpointing_suspended: bool
    forward: list[Forward]
    old_store: Incomplete
    rolled_forward: bool
    retain_after_load_flag: bool
    did_interaction: bool
    def __init__(self) -> None: ...
    def after_setstate(self) -> None: ...
    ever_been_changed: Incomplete
    def after_upgrade(self, version: int) -> None: ...
    def begin(self, force: bool = False) -> None: ...
    def replace_node(self, old, new) -> None: ...
    def complete(self, begin: bool = False) -> None: ...
    def get_roots(self): ...
    def purge_unreachable(self, roots, wait=None) -> None: ...
    def in_rollback(self): ...
    def in_fixed_rollback(self): ...
    def forward_info(self): ...
    def checkpoint(self, data=None, keep_rollback: bool = False, hard: bool = True) -> None: ...
    def suspend_checkpointing(self, flag) -> None: ...
    def block(self, purge: bool = False) -> None: ...
    def retain_after_load(self) -> None: ...
    def fix_rollback(self) -> None: ...
    def can_rollback(self): ...
    def load_failed(self) -> None: ...
    def rollback(
        self,
        checkpoints,
        force: bool = False,
        label=None,
        greedy: bool = True,
        on_load: bool = False,
        abnormal: bool = True,
        current_label=None,
    ) -> None: ...
    def freeze(self, wait=None): ...
    def discard_freeze(self) -> None: ...
    def unfreeze(self, roots, label=None) -> None: ...
    def build_identifier_cache(self) -> None: ...
    def get_identifier_checkpoints(self, identifier): ...
