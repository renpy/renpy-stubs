import renpy
from _typeshed import Incomplete as Incomplete
from renpy.display.displayable import Displayable as Displayable
from renpy.display.focus import Focus as Focus
from renpy.pygame import Surface as Surface
from renpy.test.testmouse import click_mouse as click_mouse, move_mouse as move_mouse, scroll_mouse as scroll_mouse
from renpy.test.types import (
    HookType as HookType,
    NodeLocation as NodeLocation,
    NodeState as NodeState,
    Position as Position,
    RenpyTestException as RenpyTestException,
    RenpyTestScreenshotError as RenpyTestScreenshotError,
    RenpyTestTimeoutError as RenpyTestTimeoutError,
)
from typing import Any

class SelectorException(RenpyTestException): ...

class Node:
    next: Node | None
    done: bool
    def __init__(self, loc: NodeLocation) -> None: ...
    def __eq__(self, other): ...
    def chain(self, next: Node | None) -> None: ...
    def get_repr_params(self) -> str: ...
    def restart(self) -> None: ...
    def ready(self) -> bool: ...
    def start(self) -> NodeState: ...
    def execute(self, state: NodeState, t: float) -> NodeState: ...
    def after_until(self) -> None: ...
    def cleanup_after_error(self, state: NodeState) -> None: ...

class Block(Node):
    block: Incomplete
    name: Incomplete
    def __init__(self, loc: NodeLocation, block: list[Node], name: str = "") -> None: ...
    next: Incomplete
    def chain(self, next) -> None: ...
    done: bool
    def restart(self) -> None: ...
    def execute(self, state, t) -> None: ...

class BaseTestBlock(Block):
    parent: Incomplete
    xfail_expr: Incomplete
    def __init__(
        self,
        loc: NodeLocation,
        block: list[Node],
        name: str,
        parent: TestSuite | None = None,
        xfail_expr: str = "False",
    ) -> None: ...
    def __hash__(self): ...
    def get_repr_params(self) -> str: ...
    def get_parameterized_name(self, index: int | None = None) -> str: ...
    @property
    def xfail(self) -> bool: ...
    @property
    def current_parameters(self) -> dict[str, Any]: ...
    @property
    def full_path(self) -> str: ...
    @property
    def current_parameterized_name(self) -> str: ...
    @property
    def current_full_parameterized_path(self) -> str: ...

class TestHook(BaseTestBlock):
    depth: Incomplete
    call_count: int
    def __init__(
        self,
        loc: NodeLocation,
        block: list[Node],
        name: str,
        parent: TestSuite | None = None,
        xfail_expr: str = "False",
        depth: int = 0,
    ) -> None: ...
    def increment_call_count(self) -> None: ...
    def __hash__(self): ...
    def get_parameterized_name(self, index=None): ...

class TestCase(BaseTestBlock):
    description: Incomplete
    enabled: Incomplete
    only: Incomplete
    parameters: Incomplete
    parameter_index: int
    def __init__(
        self,
        loc: NodeLocation,
        block: list[Node],
        name: str,
        parent: TestSuite | None = None,
        xfail_expr: str = "False",
        description: str = "",
        enabled: bool = True,
        only: bool = False,
        parameters: list[list[dict[str, Any]]] | None = None,
    ) -> None: ...
    def restart(self) -> None: ...
    def generate_parameter_combinations(
        self, parameters: list[list[dict[str, Any]]] | None
    ) -> list[dict[str, Any]]: ...
    def advance_to_next_parameter_set(self) -> None: ...
    def get_parameterized_name(self, index=None): ...
    @property
    def current_parameters(self) -> dict[str, Any]: ...
    @property
    def has_all_parameters_been_processed(self) -> bool: ...
    def has_testcase(self) -> bool: ...

class TestSuite(TestCase):
    subtest_index: int
    subtests: list[TestCase]
    setup: Incomplete
    before_testsuite: Incomplete
    before_testcase: Incomplete
    after_testcase: Incomplete
    after_testsuite: Incomplete
    teardown: Incomplete
    def __init__(
        self,
        loc: NodeLocation,
        name: str,
        parent: TestSuite | None = None,
        xfail_expr: str = "False",
        description: str = "",
        enabled: bool = True,
        only: bool = False,
        parameters: list[list[dict[str, Any]]] | None = None,
        subtests: list[TestCase] | None = None,
        setup: TestHook | None = None,
        before_testsuite: TestHook | None = None,
        before_testcase: TestHook | None = None,
        after_testsuite: TestHook | None = None,
        after_testcase: TestHook | None = None,
        teardown: TestHook | None = None,
    ) -> None: ...
    def chain(self, next: Node | None) -> None: ...
    def add(self, child: TestCase) -> None: ...
    parameter_index: int
    def restart(self) -> None: ...
    def advance_to_next_subtest(self) -> None: ...
    def advance_to_next_parameter_set(self) -> None: ...
    def get_hook(self, hook_type: HookType) -> TestHook | None: ...
    @property
    def hooks(self) -> list[TestHook]: ...
    @property
    def current_test(self) -> TestCase | None: ...
    @property
    def num_tests(self) -> int: ...
    @property
    def has_completed_all_subtests(self) -> bool: ...
    @property
    def full_path(self) -> str: ...
    @property
    def current_full_parameterized_path(self) -> str: ...
    def has_testcase(self) -> bool: ...

class Condition(Node):
    def execute(self, state: NodeState, t: float) -> NodeState: ...

class Selector(Condition):
    wait_for_focus: bool
    element: Displayable | Focus | None
    def __init__(self, loc, wait_for_focus) -> None: ...
    def ready(self) -> bool: ...
    def get_element(self) -> Displayable | Focus | None: ...
    def element_not_found_during_perform(self) -> None: ...
    def is_focused(self) -> bool: ...

class DisplayableSelector(Selector):
    screen: Incomplete
    id: Incomplete
    layer: Incomplete
    def __init__(
        self,
        loc: NodeLocation,
        screen: str | None = None,
        id: str | None = None,
        layer: str | None = None,
        wait_for_focus: bool = False,
    ) -> None: ...
    def ready(self) -> bool: ...
    def get_element(self) -> Displayable | None: ...
    def get_displayable(self) -> Displayable | None: ...
    def element_not_found_during_perform(self) -> None: ...

class TextSelector(Selector):
    pattern: Incomplete
    raw: Incomplete
    def __init__(
        self, loc: NodeLocation, wait_for_focus: bool = False, pattern: str = "", raw: bool = False
    ) -> None: ...
    def get_repr_params(self) -> str: ...
    def get_element(self) -> Focus | None: ...
    def element_not_found_during_perform(self) -> None: ...

class SelectorDrivenNode(Node):
    selector: Incomplete
    position: Incomplete
    always: Incomplete
    def __init__(
        self, loc: NodeLocation, selector: Selector | None = None, position: str | None = None, always: bool = False
    ) -> None: ...
    def ready(self) -> bool: ...
    def execute(self, state: NodeState, t: float) -> NodeState: ...
    def get_position(self) -> tuple[int, int]: ...
    def perform(self, x: int, y: int, state: NodeState, t: float) -> NodeState | None: ...

class Click(SelectorDrivenNode):
    button: int
    def perform(self, x, y, state, t) -> None: ...

class Move(SelectorDrivenNode):
    def perform(self, x, y, state, t) -> None: ...

class Scroll(SelectorDrivenNode):
    amount: int
    def perform(self, x, y, state, t) -> None: ...

class Drag(Node):
    start_point: Incomplete
    end_point: Incomplete
    button: Incomplete
    steps: Incomplete
    def __init__(
        self,
        loc: NodeLocation,
        start_point: SelectorDrivenNode,
        end_point: SelectorDrivenNode,
        button: int = 1,
        steps: int = 10,
    ) -> None: ...
    def ready(self): ...
    def start(self): ...
    def execute(self, state, t): ...

class Type(SelectorDrivenNode):
    text: Incomplete
    def __init__(self, loc: NodeLocation, text: str, **kwargs) -> None: ...
    def start(self): ...
    def perform(self, x, y, state, t): ...

class Keysym(SelectorDrivenNode):
    keysym: Incomplete
    def __init__(self, loc: NodeLocation, keysym: str, **kwargs) -> None: ...
    def perform(self, x, y, state, t) -> None: ...

class Action(Node):
    expr: Incomplete
    def __init__(self, loc: NodeLocation, expr: str) -> None: ...
    def ready(self): ...
    def execute(self, state, t) -> None: ...

class Pause(Node):
    expr: Incomplete
    def __init__(self, loc: NodeLocation, expr: str) -> None: ...
    def get_repr_params(self): ...
    def start(self): ...
    def execute(self, state, t): ...

class Label(Condition):
    name: Incomplete
    def __init__(self, loc: NodeLocation, name: str) -> None: ...
    def ready(self): ...
    def get_repr_params(self): ...

class Eval(Condition):
    expr: Incomplete
    def __init__(self, loc: NodeLocation, expr) -> None: ...
    def ready(self): ...

class RepeatCounter(Condition):
    initial_value: Incomplete
    def __init__(self, loc: NodeLocation, value: int) -> None: ...
    value: Incomplete
    def restart(self) -> None: ...
    def ready(self): ...

class Pass(Node): ...

class Advance(Node):
    last_event: str
    last_kwargs: dict
    began_newline: bool
    @staticmethod
    def character_callback(event, **kwargs) -> None: ...
    def ready(self): ...
    def start(self): ...
    def execute(self, state, t): ...

class Skip(Node):
    fast: Incomplete
    def __init__(self, loc: NodeLocation, fast: bool = False) -> None: ...
    def start(self): ...
    def execute(self, state, t) -> None: ...
    def after_until(self) -> None: ...

class Not(Condition):
    condition: Incomplete
    def __init__(self, loc: NodeLocation, condition: Condition) -> None: ...
    def ready(self): ...

class Binary(Condition):
    left: Incomplete
    right: Incomplete
    left_ready: Incomplete
    def __init__(self, loc: NodeLocation, left: Condition, right: Condition) -> None: ...
    def state(self) -> bool | None: ...
    left_state: Incomplete
    right_state: Incomplete
    def start(self): ...

class And(Binary):
    left_ready: Incomplete
    right_ready: Incomplete
    def ready(self): ...
    def state(self) -> bool | None: ...
    left_state: Incomplete
    right_state: Incomplete
    def execute(self, state, t): ...

class Or(Binary):
    left_ready: Incomplete
    right_ready: Incomplete
    def ready(self): ...
    def state(self) -> bool | None: ...
    left_state: Incomplete
    right_state: Incomplete
    def execute(self, state, t): ...

class Until(Node):
    left: Incomplete
    right: Incomplete
    timeout: Incomplete
    def __init__(self, loc: NodeLocation, left: Node, right: Condition, timeout: str = "None") -> None: ...
    def restart(self) -> None: ...
    def ready(self): ...
    def start(self): ...
    def execute(self, state: tuple[float | None, Any, float, bool], t): ...
    def cleanup_after_error(self, state) -> None: ...

class Repeat(Until):
    def __init__(self, loc: NodeLocation, left: Node, count: int, timeout: str = "None") -> None: ...
    def ready(self): ...

class If(Node):
    entries: Incomplete
    def __init__(self, loc: NodeLocation, entries: list[tuple[Condition, "Block"]]) -> None: ...
    next: Incomplete
    def chain(self, next) -> None: ...
    def execute(self, state, t) -> None: ...

class Python(Node):
    source: Incomplete
    hide: Incomplete
    def __init__(self, loc: NodeLocation, source: str, hide: bool = False) -> None: ...
    def execute(self, state, t) -> None: ...

class Assert(Node):
    condition: Incomplete
    timeout: Incomplete
    xfail_expr: Incomplete
    is_assertion_true: bool
    def __init__(
        self, loc: NodeLocation, condition: Condition, timeout: str = "None", xfail_expr: str = "False"
    ) -> None: ...
    def start(self): ...
    def execute(self, state, t): ...
    def cleanup_after_error(self, state) -> None: ...
    @property
    def xfail(self) -> bool: ...

class Screenshot(Node):
    max_pixel_difference: Incomplete
    crop: Incomplete
    filename_expr: Incomplete
    def __init__(
        self, loc: NodeLocation, filename: str, max_pixel_difference: str | None = None, crop: str | None = None
    ) -> None: ...
    def start(self): ...
    def execute(self, state, t) -> None: ...
    def get_reference_image_path(self, filename: str) -> str | None: ...
    def save_image(self, img: renpy.pygame.Surface, filename: str) -> None: ...

class Exit(Node):
    def execute(self, state, t) -> None: ...

def next_node(node: Node | None): ...
def scoped_eval(expr: str) -> Any: ...
def scoped_exec(source: str, hide: bool = False) -> None: ...
