import renpy
from renpy.display.displayable import Displayable as Displayable
from renpy.display.focus import Focus as Focus
from renpy.pygame import Surface as Surface
from renpy.test.testmouse import click_mouse as click_mouse, move_mouse as move_mouse, scroll_mouse as scroll_mouse
from renpy.test.testsettings import _test as _test
from renpy.test.types import (
    HookType as HookType,
    NodeLocation as NodeLocation,
    NodeState as NodeState,
    Position as Position,
    RenpyTestException as RenpyTestException,
    RenpyTestScreenshotError as RenpyTestScreenshotError,
    RenpyTestTimeoutError as RenpyTestTimeoutError,
)
from typing import Any, Literal

class SelectorException(RenpyTestException): ...

type DefaultNodeState = int

class Node[T: NodeState]:
    __slots__: str | tuple[str, ...]
    next: "Node | None"
    done: bool
    def __init__(self, loc: NodeLocation) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def chain(self, next: Node | None) -> None: ...
    def get_repr_params(self) -> str: ...
    def restart(self) -> None: ...
    def ready(self) -> bool: ...
    def start(self) -> T | None: ...
    def execute(self, state: T, t: float) -> T | None: ...
    def after_until(self) -> None: ...
    def cleanup_after_error(self, state: T) -> None: ...

class Block(Node[DefaultNodeState]):
    __slots__: str | tuple[str, ...]
    block: list[Node]
    name: str
    def __init__(self, loc: NodeLocation, block: list[Node], name: str = "") -> None: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    done: bool
    def restart(self) -> None: ...
    def execute(self, state: DefaultNodeState, t: float) -> DefaultNodeState | None: ...

class BaseTestBlock(Block):
    __slots__: str | tuple[str, ...]
    parent: TestSuite | None
    xfail_expr: str
    def __init__(
        self,
        loc: NodeLocation,
        block: list[Node],
        name: str,
        parent: TestSuite | None = None,
        xfail_expr: str = "False",
    ) -> None: ...
    def __hash__(self) -> int: ...
    def get_repr_params(self) -> str: ...
    def get_parameterized_name(self, index: int | None = None) -> str: ...
    @property
    def xfail(self) -> bool: ...
    @property
    def current_parameters(self) -> dict[str, Any]: ...
    @property
    def full_path(self) -> str: ...
    @property
    def current_parameterized_name(self) -> str: ...
    @property
    def current_full_parameterized_path(self) -> str: ...

class TestHook(BaseTestBlock):
    __slots__: str | tuple[str, ...]
    depth: int
    call_count: int
    def __init__(
        self,
        loc: NodeLocation,
        block: list[Node],
        name: str,
        parent: TestSuite | None = None,
        xfail_expr: str = "False",
        depth: int = 0,
    ) -> None: ...
    def increment_call_count(self) -> None: ...
    def __hash__(self) -> int: ...
    def get_parameterized_name(self, index: int | None = None) -> str: ...

class TestCase(BaseTestBlock):
    __slots__: str | tuple[str, ...]
    description: str
    enabled: bool
    only: bool
    parameters: list[dict[str, Any]]
    parameter_index: int
    def __init__(
        self,
        loc: NodeLocation,
        block: list[Node],
        name: str,
        parent: TestSuite | None = None,
        xfail_expr: str = "False",
        description: str = "",
        enabled: bool = True,
        only: bool = False,
        parameters: list[list[dict[str, Any]]] | None = None,
    ) -> None: ...
    def restart(self) -> None: ...
    def generate_parameter_combinations(
        self, parameters: list[list[dict[str, Any]]] | None
    ) -> list[dict[str, Any]]: ...
    def advance_to_next_parameter_set(self) -> None: ...
    def get_parameterized_name(self, index: int | None = None) -> str: ...
    @property
    def current_parameters(self) -> dict[str, Any]: ...
    @property
    def has_all_parameters_been_processed(self) -> bool: ...
    def has_testcase(self) -> bool: ...

class TestSuite(TestCase):
    __slots__: str | tuple[str, ...]
    subtest_index: int
    subtests: list[TestCase]
    setup: TestHook | None
    before_testsuite: TestHook | None
    before_testcase: TestHook | None
    after_testcase: TestHook | None
    after_testsuite: TestHook | None
    teardown: TestHook | None
    def __init__(
        self,
        loc: NodeLocation,
        name: str,
        parent: TestSuite | None = None,
        xfail_expr: str = "False",
        description: str = "",
        enabled: bool = True,
        only: bool = False,
        parameters: list[list[dict[str, Any]]] | None = None,
        subtests: list[TestCase] | None = None,
        setup: TestHook | None = None,
        before_testsuite: TestHook | None = None,
        before_testcase: TestHook | None = None,
        after_testsuite: TestHook | None = None,
        after_testcase: TestHook | None = None,
        teardown: TestHook | None = None,
    ) -> None: ...
    def chain(self, next: Node | None) -> None: ...
    def add(self, child: TestCase) -> None: ...
    parameter_index: int
    def restart(self) -> None: ...
    def advance_to_next_subtest(self) -> None: ...
    def advance_to_next_parameter_set(self) -> None: ...
    def get_hook(self, hook_type: HookType) -> TestHook | None: ...
    @property
    def hooks(self) -> list[TestHook]: ...
    @property
    def current_test(self) -> TestCase | None: ...
    @property
    def num_tests(self) -> int: ...
    @property
    def has_completed_all_subtests(self) -> bool: ...
    @property
    def full_path(self) -> str: ...
    @property
    def current_full_parameterized_path(self) -> str: ...
    def has_testcase(self) -> bool: ...

class Condition[T](Node[T]):
    def execute(self, state: T, t: float) -> T | None: ...

class Selector(Condition[DefaultNodeState]):
    __slots__: str | tuple[str, ...]
    wait_for_focus: bool
    element: Displayable | Focus | None
    def __init__(self, loc: NodeLocation, wait_for_focus: bool) -> None: ...
    def ready(self) -> bool: ...
    def get_element(self) -> Displayable | Focus | None: ...
    def element_not_found_during_perform(self) -> None: ...
    def is_focused(self) -> bool: ...

class DisplayableSelector(Selector):
    __slots__: str | tuple[str, ...]
    screen: str | None
    id: str | None
    layer: str | None
    def __init__(
        self,
        loc: NodeLocation,
        screen: str | None = None,
        id: str | None = None,
        layer: str | None = None,
        wait_for_focus: bool = False,
    ) -> None: ...
    def ready(self) -> bool: ...
    def get_element(self) -> Displayable | None: ...
    def get_displayable(self) -> Displayable | None: ...
    def element_not_found_during_perform(self) -> None: ...
    def __str__(self) -> str: ...

class TextSelector(Selector):
    __slots__: str | tuple[str, ...]
    pattern: str
    raw: bool
    def __init__(
        self, loc: NodeLocation, wait_for_focus: bool = False, pattern: str = "", raw: bool = False
    ) -> None: ...
    def get_repr_params(self) -> str: ...
    def get_element(self) -> Focus | None: ...
    def element_not_found_during_perform(self) -> None: ...

class SelectorDrivenNode[T](Node[T]):
    __slots__: str | tuple[str, ...]
    selector: Selector | None
    position: str | None
    always: bool
    def __init__(
        self, loc: NodeLocation, selector: Selector | None = None, position: str | None = None, always: bool = False
    ) -> None: ...
    def ready(self) -> bool: ...
    def execute(self, state: T | tuple[str, bool, T], t: float) -> T | tuple[str, bool, T] | None: ...
    def get_position(self) -> tuple[int, int]: ...
    def perform(self, x: int, y: int, state: T, t: float) -> T | None: ...

class Click(SelectorDrivenNode[DefaultNodeState]):
    button: int
    def perform(self, x: int, y: int, state: DefaultNodeState, t: float) -> DefaultNodeState | None: ...

class Move(SelectorDrivenNode[DefaultNodeState]):
    def perform(self, x: int, y: int, state: DefaultNodeState, t: float) -> DefaultNodeState | None: ...

class Scroll(SelectorDrivenNode[DefaultNodeState]):
    amount: int
    def perform(self, x: int, y: int, state: DefaultNodeState, t: float) -> DefaultNodeState | None: ...

type DragState = tuple[tuple[int, int], tuple[int, int], int]

class Drag(Node[DragState]):
    __slots__: str | tuple[str, ...]
    start_point: SelectorDrivenNode
    end_point: SelectorDrivenNode
    button: int
    steps: int
    def __init__(
        self,
        loc: NodeLocation,
        start_point: SelectorDrivenNode,
        end_point: SelectorDrivenNode,
        button: int = 1,
        steps: int = 10,
    ) -> None: ...
    def ready(self) -> bool: ...
    def start(self) -> DragState: ...
    def execute(self, state: DragState, t: float) -> DragState | None: ...

type TypeState = int

class Type(SelectorDrivenNode[TypeState]):
    __slots__: str | tuple[str, ...]
    text: str
    def __init__(self, loc: NodeLocation, text: str, **kwargs) -> None: ...
    def start(self) -> TypeState: ...
    def perform(self, x: int, y: int, state: TypeState, t: float) -> TypeState | None: ...

class Keysym(SelectorDrivenNode[DefaultNodeState]):
    __slots__: str | tuple[str, ...]
    keysym: str
    def __init__(self, loc: NodeLocation, keysym: str, **kwargs) -> None: ...
    def perform(self, x: int, y: int, state: DefaultNodeState, t: float) -> DefaultNodeState | None: ...

class Action(Node[DefaultNodeState]):
    __slots__: str | tuple[str, ...]
    expr: str
    def __init__(self, loc: NodeLocation, expr: str) -> None: ...
    def ready(self) -> bool: ...
    def execute(self, state: DefaultNodeState, t: float) -> DefaultNodeState | None: ...

type PauseState = tuple[float, float]

class Pause(Node[PauseState]):
    __slots__: str | tuple[str, ...]
    expr: str
    def __init__(self, loc: NodeLocation, expr: str) -> None: ...
    def get_repr_params(self) -> str: ...
    def start(self) -> PauseState: ...
    def execute(self, state: PauseState, t: float) -> PauseState | None: ...

class Label(Condition[DefaultNodeState]):
    __slots__: str | tuple[str, ...]
    name: str
    def __init__(self, loc: NodeLocation, name: str) -> None: ...
    def ready(self) -> bool: ...
    def get_repr_params(self) -> str: ...

class Eval(Condition[DefaultNodeState]):
    __slots__: str | tuple[str, ...]
    expr: str
    def __init__(self, loc: NodeLocation, expr: str) -> None: ...
    def ready(self) -> bool: ...

class RepeatCounter(Condition[DefaultNodeState]):
    __slots__: str | tuple[str, ...]
    initial_value: int
    def __init__(self, loc: NodeLocation, value: int) -> None: ...
    value: int
    def restart(self) -> None: ...
    def ready(self) -> bool: ...

class Pass(Node[DefaultNodeState]): ...

type AdvanceState = str

class Advance(Node[AdvanceState]):
    last_event: str
    last_kwargs: dict[str, Any]
    began_newline: bool
    @staticmethod
    def character_callback(event: str, **kwargs) -> None: ...
    def ready(self) -> bool: ...
    def start(self) -> AdvanceState: ...
    def execute(self, state: AdvanceState, t: float) -> AdvanceState | None: ...

type SkipState = Literal[True]

class Skip(Node[SkipState]):
    __slots__: str | tuple[str, ...]
    fast: bool
    def __init__(self, loc: NodeLocation, fast: bool = False) -> None: ...
    def start(self) -> SkipState | None: ...
    def execute(self, state: SkipState, t: float) -> SkipState | None: ...
    def after_until(self) -> None: ...

class Not(Condition):
    __slots__: str | tuple[str, ...]
    condition: Condition
    def __init__(self, loc: NodeLocation, condition: Condition) -> None: ...
    def ready(self) -> bool: ...

type BinaryState = bool

class Binary(Condition[BinaryState]):
    __slots__: str | tuple[str, ...]
    left: Condition
    right: Condition
    left_ready: bool | None
    right_ready: bool | None
    def __init__(self, loc: NodeLocation, left: Condition, right: Condition) -> None: ...
    def state(self) -> BinaryState | None: ...
    left_state: NodeState | None
    right_state: NodeState | None
    def start(self) -> BinaryState | None: ...

class And(Binary):
    __slots__: str | tuple[str, ...]
    left_ready: bool | None
    right_ready: bool | None
    def ready(self) -> bool: ...
    def state(self) -> BinaryState | None: ...
    left_state: NodeState | None
    right_state: NodeState | None
    def execute(self, state: BinaryState, t: float) -> BinaryState | None: ...

class Or(Binary):
    __slots__: str | tuple[str, ...]
    left_ready: bool | None
    right_ready: bool | None
    def ready(self) -> bool: ...
    def state(self) -> BinaryState | None: ...
    left_state: NodeState | None
    right_state: NodeState | None
    def execute(self, state: BinaryState, t: float) -> BinaryState | None: ...

type UntilState = tuple[float, Any, float, bool]

class Until(Node[UntilState]):
    __slots__: str | tuple[str, ...]
    left: Node
    right: Condition
    timeout: str
    def __init__(self, loc: NodeLocation, left: Node, right: Condition, timeout: str = "None") -> None: ...
    def restart(self) -> None: ...
    def ready(self) -> bool: ...
    def start(self) -> UntilState: ...
    def execute(self, state: UntilState, t: float) -> UntilState | None: ...
    def cleanup_after_error(self, state: UntilState) -> None: ...

class Repeat(Until):
    def __init__(self, loc: NodeLocation, left: Node, count: int, timeout: str = "None") -> None: ...
    def ready(self) -> bool: ...

class If(Node[DefaultNodeState]):
    __slots__: str | tuple[str, ...]
    entries: list[tuple[Condition, Block]]
    def __init__(self, loc: NodeLocation, entries: list[tuple[Condition, Block]]) -> None: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def execute(self, state: DefaultNodeState, t: float) -> DefaultNodeState | None: ...

class Python(Node[DefaultNodeState]):
    __slots__: str | tuple[str, ...]
    source: str
    hide: bool
    def __init__(self, loc: NodeLocation, source: str, hide: bool = False) -> None: ...
    def execute(self, state: DefaultNodeState, t: float) -> DefaultNodeState | None: ...

type AssertState = float

class Assert(Node[AssertState]):
    __slots__: str | tuple[str, ...]
    condition: Condition
    timeout: str
    xfail_expr: str
    is_assertion_true: bool
    def __init__(
        self, loc: NodeLocation, condition: Condition, timeout: str = "None", xfail_expr: str = "False"
    ) -> None: ...
    def start(self) -> AssertState: ...
    def execute(self, state: AssertState, t: float) -> AssertState | None: ...
    def cleanup_after_error(self, state: AssertState) -> None: ...
    @property
    def xfail(self) -> bool: ...

type ScreenshotState = str

class Screenshot(Node[ScreenshotState]):
    __slots__: str | tuple[str, ...]
    max_pixel_difference: str | None
    crop: str | None
    filename_expr: str
    def __init__(
        self, loc: NodeLocation, filename: str, max_pixel_difference: str | None = None, crop: str | None = None
    ) -> None: ...
    def start(self) -> ScreenshotState: ...
    def execute(self, state: ScreenshotState, t: float) -> ScreenshotState | None: ...
    def get_reference_image_path(self, filename: str) -> str | None: ...
    def save_image(self, img: renpy.pygame.Surface, filename: str) -> None: ...

class Exit(Node[DefaultNodeState]):
    def execute(self, state: DefaultNodeState, t: float) -> DefaultNodeState | None: ...

def next_node(node: Node | None) -> None: ...
def scoped_eval(expr: str) -> Any: ...
def scoped_exec(source: str, hide: bool = False) -> None: ...
