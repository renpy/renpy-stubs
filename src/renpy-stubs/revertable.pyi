import random
from _collections_abc import dict_items as dict_items, dict_keys as dict_keys, dict_values as dict_values
from _typeshed import Incomplete as Incomplete
from typing import Any, Callable, Iterable, Self, overload

FUTURE_FLAGS: int

def _reconstructor(cls, base, state): ...

mutate_flag: bool

def mutator(method: Incomplete) -> Incomplete: ...

class CompressedList[T]:
    pre: list[T]
    start: int
    end: int
    post: list[T]
    def __init__(self, old: list[T], new: list[T]) -> None: ...
    def decompress(self, new: list[T]) -> list[T]: ...
    def __repr__(self) -> str: ...

class RevertableList[T](list[T]):
    def __init__(self, *args) -> None: ...
    def wrapper(method: Incomplete) -> Incomplete: ...
    @overload
    def __getitem__(self, index: int) -> T: ...
    @overload
    def __getitem__(self, index: slice) -> RevertableList[T]: ...
    def copy(self) -> RevertableList[T]: ...
    def clear(self) -> None: ...
    def _clean(self) -> RevertableList[T]: ...
    def _compress(self, clean: RevertableList[T]) -> RevertableList[T] | CompressedList[T]: ...
    def _rollback(self, compressed: CompressedList[T] | list[T]) -> None: ...

def revertable_range(*args) -> RevertableList[int]: ...
def revertable_sorted[T](*args: list[Iterable[T]], **kwargs) -> RevertableList[T]: ...

class RevertableDict[KT, VT](dict[KT, VT]):
    def __init__(self, *args, **kwargs) -> None: ...
    def has_key(self, key: KT) -> bool: ...
    def __or__(self, other: object) -> RevertableDict[KT, VT]: ...
    def __ror__(self, other: object) -> RevertableDict[KT, VT]: ...
    def __ior__(self, other: Incomplete) -> Self: ...
    def copy(self) -> RevertableDict[KT, VT]: ...
    def _clean(self) -> list[tuple[KT, VT]]: ...
    def _compress(self, clean: list[tuple[KT, VT]]) -> list[tuple[KT, VT]]: ...
    def _rollback(self, compressed: list[tuple[KT, VT]]) -> None: ...

class RevertableDefaultDict[KT, VT](RevertableDict[KT, VT]):
    default_factory: Callable[..., VT] | None
    def __init__(self, default_factory: Callable[..., VT] | None = None, *args, **kwargs) -> None: ...
    def __missing__(self, key: KT) -> VT: ...

class RevertableSet[T](set[T]):
    def __setstate__(self, state) -> None: ...
    def __getstate__(self): ...
    def __init__(self, *args: Iterable[T]) -> None: ...
    def wrapper(method: Incomplete) -> Incomplete: ...
    def _clean(self) -> list[T]: ...
    def _compress(self, clean: list[T]) -> list[T]: ...
    def _rollback(self, compressed: list[T]) -> None: ...

class RevertableObject:
    def __new__(cls, *args, **kwargs) -> Self: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __init_subclass__(cls) -> None: ...
    def _clean(self) -> dict[str, Any]: ...
    def _compress(self, clean: dict[str, Any]) -> dict[str, Any]: ...
    def _rollback(self, compressed: dict[str, Any]) -> None: ...

class MultiRevertable:
    def _rollback_types(self) -> list[type]: ...
    def _clean(self) -> tuple[Any, ...]: ...
    def _compress(self, clean: tuple[Any, ...]) -> tuple[Any, ...]: ...
    def _rollback(self, compressed: tuple[Any, ...]) -> None: ...

def checkpointing(method: Incomplete) -> Incomplete: ...
def list_wrapper(method: Incomplete) -> Incomplete: ...

class RollbackRandom(random.Random):
    def __init__(self) -> None: ...
    def _clean(self) -> tuple[Any, ...]: ...
    def _compress(self, clean: tuple[Any, ...]) -> tuple[Any, ...]: ...
    def _rollback(self, compressed: tuple[Any, ...]) -> None: ...
    def Random(self, seed: int | float | str | bytes | bytearray | None = None) -> RollbackRandom: ...

class DetRandom(random.Random):
    stack: list[float]
    def __init__(self) -> None: ...
    def random(self) -> float: ...
    def pushback(self, l: list[float]) -> None: ...
    def reset(self) -> None: ...
    def Random(self, seed: int | float | str | bytes | bytearray | None = None) -> RollbackRandom: ...
