import contextlib
import renpy
from _typeshed import Incomplete as Incomplete
from collections.abc import Generator
from renpy.ast import PyExpr as PyExpr
from typing import Callable, NamedTuple

def match_logical_word(s: str, pos: int) -> tuple[str, bool, int]: ...
def make_pyexpr(s: str, filename: str, linenumber: int, column: int, text: str, pos: int) -> renpy.ast.PyExpr: ...

class ParseError(SyntaxError):
    def __init__(
        self,
        message: str,
        filename: str,
        lineno: int,
        offset: int | None = None,
        text: str | None = None,
        end_lineno: int | None = None,
        end_offset: int | None = None,
    ) -> None: ...
    @property
    def message(self) -> str: ...
    def defer(self, queue) -> None: ...

class LineNumberHolder:
    line: int
    def __init__(self) -> None: ...

def unicode_filename(fn): ...

lllword: Incomplete

def munge_filename(fn): ...
def elide_filename(fn): ...
def unelide_filename(fn: str) -> str: ...
def get_string_munger(prefix: str) -> Callable[[str], str]: ...

original_filename: str

def list_logical_lines(
    filename: str, filedata: str | None = None, linenumber: int = 1
) -> list[tuple[str, int, str]]: ...

class GroupedLine(NamedTuple):
    filename: str
    number: int
    indent: int
    text: str
    block: list["GroupedLine"]

def group_logical_lines(lines: list[tuple[str, int, str]]) -> list[GroupedLine]: ...

KEYWORDS: Incomplete
IMAGE_KEYWORDS: Incomplete
OPERATORS: Incomplete
ESCAPED_OPERATORS: Incomplete
operator_regexp: Incomplete
word_regexp: str
image_word_regexp: str

class SubParse:
    block: Incomplete
    def __init__(self, block) -> None: ...

class Lexer:
    block: list[GroupedLine]
    init: Incomplete
    init_priority: int
    init_offset: Incomplete
    eob: bool
    line: int
    filename: str
    text: str
    number: int
    subblock: Incomplete
    global_label: Incomplete
    pos: int
    word_cache_pos: int
    word_cache_newpos: int
    word_cache: str
    column: int
    monologue_delimiter: Incomplete
    subparses: Incomplete
    def __init__(
        self,
        block,
        init: bool = False,
        init_offset: int = 0,
        global_label=None,
        monologue_delimiter: str = "\n\n",
        subparses=None,
    ) -> None: ...
    def advance(self): ...
    def unadvance(self) -> None: ...
    def match_regexp(self, regexp): ...
    def skip_whitespace(self) -> None: ...
    def match(self, regexp): ...
    def match_multiple(self, *regexps): ...
    def keyword(self, word): ...
    @contextlib.contextmanager
    def catch_error(self) -> Generator[None]: ...
    def error(self, msg) -> None: ...
    def deferred_error(self, queue, msg) -> None: ...
    def eol(self): ...
    def expect_eol(self) -> None: ...
    def expect_noblock(self, stmt) -> None: ...
    def expect_block(self, stmt) -> None: ...
    def has_block(self): ...
    def subblock_lexer(self, init: bool = False): ...
    def string(self): ...
    def triple_string(self): ...
    def integer(self): ...
    def float(self): ...
    def hash(self): ...
    def word(self): ...
    def name(self): ...
    def set_global_label(self, label) -> None: ...
    def label_name(self): ...
    def image_name_component(self): ...
    def python_string(self): ...
    def dotted_name(self): ...
    def expr(self, s, expr): ...
    def delimited_python(self, delim, expr: bool = True): ...
    def python_expression(self, expr: bool = True): ...
    def parenthesised_python(self): ...
    def simple_expression(self, comma: bool = False, operator: bool = True, image: bool = False): ...
    def comma_expression(self): ...
    def say_expression(self): ...
    def checkpoint(self): ...
    def revert(self, state) -> None: ...
    def get_location(self): ...
    def require(self, thing, name=None, **kwargs): ...
    def rest(self): ...
    rest_statement = rest
    def python_block(self): ...
    def arguments(self): ...
    def renpy_statement(self): ...
    def renpy_block(self, empty: bool = False): ...

def ren_py_to_rpy_offsets(lines: list[str], filename: str): ...
def ren_py_to_rpy(text: str, filename: str | None) -> str: ...
def lex_string(text: str, filename: str = "<string>", linenumber: int = 1, advance: bool = True) -> Lexer: ...
