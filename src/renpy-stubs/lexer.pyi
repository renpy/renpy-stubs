import contextlib
import re
import renpy
from _typeshed import Incomplete as Incomplete
from collections.abc import Generator
from renpy.ast import PyExpr as PyExpr
from typing import Callable, Iterator, Literal, NamedTuple, Never, overload

def match_logical_word(s: str, pos: int) -> tuple[str, bool, int]: ...
def make_pyexpr(s: str, filename: str, linenumber: int, column: int, text: str, pos: int) -> renpy.ast.PyExpr: ...

class ParseError(SyntaxError):
    _message: str | None
    def __init__(
        self,
        message: str,
        filename: str,
        lineno: int,
        offset: int | None = None,
        text: str | None = None,
        end_lineno: int | None = None,
        end_offset: int | None = None,
    ) -> None: ...
    @property
    def message(self) -> str: ...
    def defer(self, queue: Incomplete) -> None: ...

class LineNumberHolder:
    line: int
    def __init__(self) -> None: ...

def unicode_filename(fn: str | bytes) -> str: ...

lllword: re.Pattern[str]

def munge_filename(fn: str) -> str: ...
def elide_filename(fn: str) -> str: ...
def unelide_filename(fn: str) -> str: ...
def get_string_munger(prefix: str) -> Callable[[str], str]: ...

original_filename: str
_ANY_OPERATOR_REGEX: re.Pattern[str]

def list_logical_lines(
    filename: str, filedata: str | None = None, linenumber: int = 1
) -> list[tuple[str, int, str]]: ...

class GroupedLine(NamedTuple):
    filename: str
    number: int
    indent: int
    text: str
    block: list["GroupedLine"]

def group_logical_lines(lines: list[tuple[str, int, str]]) -> list[GroupedLine]: ...

KEYWORDS: set[str]
IMAGE_KEYWORDS: set[str]
OPERATORS: list[str]
ESCAPED_OPERATORS: list[str]
operator_regexp: str
word_regexp: str
image_word_regexp: str

class SubParse:
    block: list[renpy.ast.Node]
    def __init__(self, block: list[renpy.ast.Node]) -> None: ...
    def __repr__(self) -> str: ...

class Lexer:
    block: list[GroupedLine]
    init: bool
    init_priority: int
    init_offset: int
    eob: bool
    line: int
    filename: str
    text: str
    number: int
    subblock: list[GroupedLine]
    global_label: str | None
    pos: int
    word_cache_pos: int
    word_cache_newpos: int
    word_cache: str | None
    column: int
    monologue_delimiter: str
    subparses: list[SubParse] | None
    def __init__(
        self,
        block: list[GroupedLine] | list[tuple[str, int, str, list[GroupedLine]]],
        init: bool = False,
        init_offset: int = 0,
        global_label: str | None = None,
        monologue_delimiter: str = "\n\n",
        subparses: list[SubParse] | None = None,
    ) -> None: ...
    def advance(self) -> bool: ...
    def unadvance(self) -> None: ...
    def match_regexp(self, regexp: str) -> str | None: ...
    def skip_whitespace(self) -> None: ...
    def match(self, regexp: str) -> str | None: ...
    def match_multiple(self, *regexps: str) -> tuple[str, ...] | None: ...
    def keyword(self, word: str) -> str: ...
    @contextlib.contextmanager
    def catch_error(self) -> Generator[None]: ...
    def error(self, msg: str) -> Never: ...
    def deferred_error(self, queue: str, msg: str) -> None: ...
    def eol(self) -> bool: ...
    def expect_eol(self) -> None: ...
    def expect_noblock(self, stmt: str) -> None: ...
    def expect_block(self, stmt: str) -> None: ...
    def has_block(self) -> bool: ...
    def subblock_lexer(self, init: bool = False) -> Lexer: ...
    def string(self) -> str | None: ...
    def triple_string(self) -> str | list[str] | None: ...
    def integer(self) -> str | None: ...
    def float(self) -> str | None: ...
    def hash(self) -> str | None: ...
    def word(self) -> str | None: ...
    def name(self) -> str | None: ...
    def set_global_label(self, label: str | None) -> None: ...
    def label_name(self) -> str | None: ...
    def image_name_component(self) -> str | None: ...
    def python_string(self) -> str | Literal[False] | None: ...
    def dotted_name(self) -> str | None: ...
    @overload
    def expr(self, s: str, expr: Literal[True]) -> PyExpr: ...
    @overload
    def expr(self, s: str, expr: Literal[False]) -> str: ...
    def delimited_python(self, delim: str, expr: bool = True) -> str: ...
    @overload
    def python_expression(self, expr: Literal[True]) -> PyExpr: ...
    @overload
    def python_expression(self, expr: Literal[False]) -> str: ...
    def parenthesised_python(self) -> bool: ...
    def simple_expression(self, comma: bool = False, operator: bool = True, image: bool = False) -> str | None: ...
    def comma_expression(self) -> str | None: ...
    def say_expression(self) -> str | None: ...
    def checkpoint(self) -> tuple[int, str, int, str, list[GroupedLine], int, int, Incomplete]: ...
    def revert(self, state: tuple[int, str, int, str, list[GroupedLine], int, int, Incomplete]) -> None: ...
    def get_location(self) -> tuple[str, int]: ...
    def require(self, thing: str | Callable[..., str | None], name: str | None = None, **kwargs) -> str: ...
    def rest(self) -> PyExpr: ...
    rest_statement = rest
    def _process_python_block(self, block: list[GroupedLine], rv: list[str], line_holder: LineNumberHolder) -> None: ...
    def python_block(self) -> str: ...
    def arguments(self) -> renpy.parameter.ArgumentInfo | None: ...
    def renpy_statement(self) -> SubParse: ...
    def renpy_block(self, empty: bool = False) -> SubParse: ...

def ren_py_to_rpy_offsets(lines: list[str], filename: str) -> Iterator[int | None]: ...
def ren_py_to_rpy(text: str, filename: str | None) -> str: ...
def lex_string(text: str, filename: str = "<string>", linenumber: int = 1, advance: bool = True) -> Lexer: ...
