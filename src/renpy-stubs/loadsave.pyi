import renpy
import threading
from renpy.compat.pickle import (
    dump as dump,
    dump_paths as dump_paths,
    find_bad_reduction as find_bad_reduction,
    loads as loads,
)
from typing import Any, overload

savegame_suffix: str

class SaveAbort(Exception): ...

def safe_rename(old: str, new: str) -> None: ...

class SaveRecord:
    screenshot: bytes | None
    extra_info: str
    json: str
    log: bytes
    first_filename: str | None
    def __init__(self, screenshot: bytes | None, extra_info: str, json: str, log: bytes) -> None: ...
    def write_file(self, filename: str) -> None: ...

def save(
    slotname: str,
    extra_info: str = "",
    mutate_flag: bool = False,
    include_screenshot: bool = True,
    extra_json: dict[str, Any] | None = None,
) -> None: ...

autosave_thread: threading.Thread | None
autosave_not_running: threading.Event
autosave_counter: int
did_autosave: bool

def autosave_thread_function(take_screenshot: bool) -> None: ...
def autosave() -> None: ...
def force_autosave(take_screenshot: bool = False, block: bool = False) -> None: ...
def scan_saved_game(slotname: str) -> tuple[str, renpy.display.im.ZipFileImage | None, float] | None: ...
def list_saved_games(
    regexp: str = ".", fast: bool = False
) -> list[str] | list[tuple[str, str, renpy.display.im.ZipFileImage | None, float | None]]: ...
def list_slots(regexp: str | None = None) -> list[str]: ...

accessed_slots: set[str]
newest_slot_cache: dict[str | None, str | None]

def newest_slot(regexp: str | None = None) -> str | None: ...
def slot_mtime(slotname: str) -> float | None: ...
def slot_json(slotname: str) -> dict[str, Any]: ...
def slot_screenshot(slotname: str) -> renpy.display.im.ZipFileImage | None: ...
def can_load(filename: str, test: bool = False) -> bool: ...
def load(filename: str) -> None: ...
def get_save_data(filename: str) -> dict[str, Any] | None: ...
def unlink_save(filename: str) -> None: ...
def rename_save(old: str, new: str) -> None: ...
def copy_save(old: str, new: str) -> None: ...
def cycle_saves(name: str, count: int) -> None: ...

unknown: renpy.object.Sentinel

@overload
def wrap_json[T](d: T) -> T: ...
@overload
def wrap_json(d: dict) -> renpy.revertable.RevertableDict: ...
@overload
def wrap_json(d: list) -> list[renpy.revertable.RevertableDict]: ...

class Cache:
    slotname: str
    def __init__(self, slotname: str) -> None: ...
    mtime: float | None | renpy.object.Sentinel
    json: dict[str, Any] | None | renpy.object.Sentinel
    screenshot: renpy.display.im.ZipFileImage | None | renpy.object.Sentinel
    def clear(self) -> None: ...
    def get_mtime(self) -> float | None: ...
    def get_json(self) -> dict[str, Any]: ...
    def get_screenshot(self) -> renpy.display.im.ZipFileImage | None: ...
    def preload(self) -> None: ...

cache: dict[str, Cache]

def get_cache(slotname: str) -> Cache: ...
def clear_slot(slotname: str) -> None: ...
def clear_cache() -> None: ...
def init() -> None: ...

location: renpy.savelocation.MultiLocation | None
