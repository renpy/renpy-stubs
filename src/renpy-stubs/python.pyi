import ast
import contextlib
from _typeshed import Incomplete as Incomplete
from collections.abc import Generator
import renpy
from renpy.astsupport import hash32 as hash32
from renpy.pydict import DictItems as DictItems, find_changes as find_changes
import types
from typing import Any, Literal, Callable, Sequence, overload

class StoreModule:
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    def __init__(self, d: Incomplete) -> None: ...
    def __setattr__(self, key: Incomplete, value: Incomplete) -> None: ...
    def __delattr__(self, key: Incomplete) -> None: ...

def get_store_module(name: str) -> types.ModuleType: ...

class StoreDict(dict):
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    old: DictItems
    ever_been_changed: set[str]
    def __init__(self) -> None: ...
    def reset(self) -> None: ...
    def begin(self) -> None: ...
    def get_changes(self, cycle: bool, previous: dict[str, Any] | None) -> tuple[dict[str, Any], set[str]] | None: ...

def begin_stores() -> None: ...

store_dicts: dict[str, StoreDict]
store_modules: dict[str, types.ModuleType]
initialized_store_dicts: set[str]

def create_store(name: str) -> None: ...

class StoreBackup:
    store: dict[str, dict]
    old: dict[str, dict]
    ever_been_changed: dict[str, set[str]]
    def __init__(self) -> None: ...
    def backup_one(self, name: str) -> None: ...
    def restore_one(self, name: str) -> None: ...
    def restore(self) -> None: ...

clean_store_backup: StoreBackup | None

def make_clean_stores() -> None: ...
def clean_stores() -> None: ...
def clean_store(name: str) -> None: ...
def reset_store_changes(name: str) -> None: ...
def mark_changed(name: str, variable: str) -> None: ...

class LoadedVariables(ast.NodeVisitor):
    def visit_Name(self, node: ast.Name) -> None: ...
    def visit_MatchMapping(self, node: ast.MatchMapping) -> None: ...
    def visit_MatchStar(self, node: ast.MatchStar) -> None: ...
    def visit_MatchAs(self, node: ast.MatchAs) -> None: ...
    def visit_arg(self, node: ast.arg) -> None: ...
    loaded: set[str]
    stored: set[str]
    def find(self, node: ast.AST) -> set[str]: ...

find_loaded_variables: Callable[[ast.AST], set[str]]

class StarredVariables(ast.NodeVisitor):
    def visit_Starred(self, node: ast.Starred) -> None: ...
    def visit_Name(self, node: ast.Name) -> None: ...
    starred: set[str]
    def find(self, targets: Sequence[ast.AST]) -> set[str]: ...

find_starred_variables: Callable[[ast.AST], set[str]]

class FindStarredMatchPatterns(ast.NodeVisitor):
    vars: list[tuple[str, Literal["dict", "list"]]]
    def __init__(self) -> None: ...
    def visit_MatchStar(self, node: ast.MatchStar) -> None: ...
    def visit_MatchMapping(self, node: ast.MatchMapping) -> None: ...

def find_starred_match_patterns(node: ast.AST) -> list[tuple[str, Literal["dict", "list"]]]: ...

class WrapNode(ast.NodeTransformer):
    call_import_from: bool
    def __init__(self) -> None: ...
    def wrap_generator(self, node: ast.AST) -> ast.Call: ...
    def wrap_starred_assign(
        self, n: ast.Assign | ast.AnnAssign, targets: list[ast.expr]
    ) -> ast.Assign | ast.AnnAssign | ast.Try: ...
    @overload
    def wrap_starred_for(self, node: ast.For) -> ast.For: ...
    @overload
    def wrap_starred_for(self, node: ast.AsyncFor) -> ast.AsyncFor: ...
    def wrap_starred_for(self, node: ast.For | ast.AsyncFor) -> ast.For | ast.AsyncFor: ...
    @overload
    def wrap_starred_with(self, node: ast.With) -> ast.With: ...
    @overload
    def wrap_starred_with(self, node: ast.AsyncWith) -> ast.AsyncWith: ...
    def wrap_starred_with(self, node: ast.With | ast.AsyncWith) -> ast.With | ast.AsyncWith: ...
    def wrap_match_case(self, node: ast.match_case) -> ast.match_case: ...
    def visit_Assign(self, node: ast.Assign) -> ast.AST: ...
    def visit_AnnAssign(self, node: ast.AnnAssign) -> ast.AST: ...
    def visit_For(self, node: ast.For) -> ast.For: ...
    def visit_AsyncFor(self, node: ast.AsyncFor) -> ast.AsyncFor: ...
    def visit_With(self, node: ast.With) -> ast.With: ...
    def visit_AsyncWith(self, node: ast.AsyncWith) -> ast.AsyncWith: ...
    def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef: ...
    def visit_GeneratorExp(self, node: ast.GeneratorExp) -> ast.Call: ...
    def visit_SetComp(self, node: ast.SetComp) -> ast.Call: ...
    def visit_Set(self, node: ast.Set) -> ast.Call: ...
    def visit_ListComp(self, node: ast.ListComp) -> ast.Call: ...
    def visit_List(self, node: ast.List) -> ast.AST: ...
    def visit_DictComp(self, node: ast.DictComp) -> ast.Call: ...
    def visit_Dict(self, node: ast.Dict) -> ast.Call: ...
    def visit_Match(self, node: ast.Match) -> ast.Match: ...
    def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.AST: ...
    def visit_ImportFrom(self, node: ast.ImportFrom) -> ast.ImportFrom | list[ast.AST]: ...

wrap_node: WrapNode

def wrap_hide(tree: Incomplete) -> None: ...

compile_warnings: list[tuple[str, int, str]]

@contextlib.contextmanager
def save_warnings() -> Generator[None]: ...

file_compiler_flags: dict[str, int]
py_compile_cache: dict[tuple[int, int, str, str, bytes, int, int], tuple[str, str] | types.CodeType]
old_py_compile_cache: dict[tuple[int, int, str, str, bytes, int, int], tuple[str, str] | types.CodeType]

class LocationFixer:
    line_delta: int
    first_line_col_delta: int
    rest_line_col_delta: int
    def __init__(
        self,
        node: ast.Module | ast.Expression,
        line_delta: int = 0,
        first_line_col_delta: int = 0,
        rest_line_col_delta: int = 0,
    ) -> None: ...
    def fix(self, node: ast.AST, lineno: int, col_offset: int) -> None: ...

def quote_eval(s: str) -> str: ...

IMMUTABLE_TYPES: tuple[type, ...]

def is_immutable_value(v: Any) -> bool: ...
def py_compile(
    source: str | ast.Module | renpy.ast.PyExpr,
    mode: Literal["eval", "exec", "hide"],
    filename: str = "<none>",
    lineno: int = 1,
    ast_node: bool = False,
    cache: bool = True,
    py: int | None = None,
    hashcode: int | None = None,
    column: int = 0,
) -> Any: ...
def py_exec_bytecode(
    bytecode: str,
    hide: bool = False,
    globals: dict[str, Any] | None = None,
    locals: dict[str, Any] | None = None,
    store: str = "store",
) -> None: ...
def py_exec(source: str, hide: bool = False, store: dict[str, Any] | None = None) -> None: ...
def py_eval_bytecode(
    bytecode: str | types.CodeType, globals: dict[str, Any] | None = None, locals: dict[str, Any] | None = None
) -> Any: ...
def py_eval(
    code: str | types.CodeType, globals: dict[str, Any] | None = None, locals: dict[str, Any] | None = None
) -> Any: ...
def store_eval(code: str, globals: dict[str, Any] | None = None, locals: dict[str, Any] | None = None) -> Any: ...
def raise_at_location(e: Exception, loc: tuple[str, int]) -> None: ...

class StoreProxy:
    def __getattr__(self, k: str) -> Any: ...
    def __setattr__(self, k: str, v: Any) -> None: ...
    def __delattr__(self, k: str) -> None: ...

def method_unpickle(obj: Any, name: str) -> Any: ...
def module_pickle(module: types.ModuleType) -> tuple[Callable[[str], types.ModuleType], tuple[str]]: ...
def module_unpickle(name: str) -> types.ModuleType: ...
def construct_None(*args) -> None: ...
