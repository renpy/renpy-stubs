import renpy
from renpy.object import Object as Object
from renpy.parameter import Signature as Signature, ValuedParameter as ValuedParameter
from renpy.pyanalysis import Analysis as Analysis, GLOBAL_CONST as GLOBAL_CONST, NOT_CONST as NOT_CONST
from renpy.types import Unused
from typing import Any, Callable, Literal, TypeVar, overload

type NodeLocation = renpy.ast.NodeLocation
type Lexer = renpy.lexer.Lexer
type BlockState = tuple[int, int, int, int, list[tuple[float, int]], Any | None]
type Warper = Callable[[float], float]
type Position = renpy.types.Position
type Displayable = renpy.display.displayable.Displayable
T = TypeVar("T")

def late_imports() -> None: ...
def compiling(loc: NodeLocation) -> None: ...
def executing(loc: NodeLocation) -> None: ...

warpers: dict[str, Warper]

def atl_warper(f: Warper) -> Warper: ...
@atl_warper
def pause(t: float) -> float: ...
@atl_warper
def instant(t: float) -> float: ...

class DualAngle:
    absolute: float
    relative: float
    def __init__(self, absolute: float, relative: float) -> None: ...
    @classmethod
    def from_any(cls, other: Any) -> DualAngle: ...
    def __add__(self, other: DualAngle) -> DualAngle: ...
    def __sub__(self, other: DualAngle) -> DualAngle: ...
    def __mul__(self, other: int | float) -> DualAngle: ...
    __rmul__ = __mul__
    def __neg__(self) -> DualAngle: ...

def position_or_none(x: Any) -> position | None: ...
def any_object(x: T) -> T: ...
def bool_or_none(x: bool | None) -> bool | None: ...
def float_or_none(x: float | None) -> float | None: ...
def matrix(x: Any) -> Matrix | None | Callable: ...
@overload
def mesh(x: renpy.gl2.gl2mesh2.Mesh2) -> renpy.gl2.gl2mesh2.Mesh2: ...
@overload
def mesh(x: renpy.gl2.gl2mesh3.Mesh3) -> renpy.gl2.gl2mesh3.Mesh3: ...
@overload
def mesh(x: tuple) -> tuple: ...
@overload
def mesh(x: Any) -> bool: ...

PROPERTIES: dict[str, Any]
tuple_or_list: tuple[type, ...]

@overload
def interpolate(t: float, a: T, b: T, typ: Callable[[Any], T]) -> T: ...
@overload
def interpolate(t: float, a: Any, b: Callable[[Any | None, float], Any | None], typ: Callable[[Any], Any]) -> Any: ...
@overload
def interpolate_spline(
    t: float, spline: list[tuple[Any, ...]], typ: tuple[Callable[[Any], T], ...]
) -> tuple[T, ...]: ...
@overload
def interpolate_spline(t: float, spline: list[Any], typ: Callable[[Any], T]) -> T | None: ...
def get_catmull_rom_value(t: float, p_1: Any, p0: Any, p1: Any, p2: Any) -> Any: ...

compile_queue: list[ATLTransformBase]

def compile_all() -> None: ...

NotInContext: renpy.object.Sentinel

class Context:
    context: dict[str, Any]
    def __init__(self, context: dict[str, Any]) -> None: ...
    def eval(self, expr: str) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...

class ATLTransformBase(renpy.object.Object):
    __version__: int
    parameters: renpy.ast.Signature
    parent_transform: ATLTransformBase | None
    atl_st_offset: float | None
    predict_block: Block | None
    nosave: list[str]
    def after_upgrade(self, version: int): ...
    atl: RawBlock | None
    context: Context
    block: Block | None
    properties: list[tuple[str, Any]] | None
    atl_state: Any | None
    done: bool
    transform_event: str | None
    last_transform_event: str | None
    last_child_transform_event: str | None
    raw_child: Displayable | None
    def __init__(
        self, atl: RawBlock | None, context: dict[str, Any], parameters: renpy.ast.Signature | None
    ) -> None: ...
    @property
    def transition(self) -> bool: ...
    def _handles_event(self, event: str) -> bool: ...
    def get_block(self) -> Block | None: ...
    st: Unused
    at: Unused
    st_offset: Unused
    at_offset: Unused
    child: Displayable | None
    def take_execution_state(self, t: ATLTransformBase) -> None: ...
    def __call__(self, *args, **kwargs) -> ATLTransformBase: ...
    def compile(self) -> Block: ...
    def execute(self, trans: ATLTransformBase, st: float, at: float) -> float | None: ...
    def predict_one(self) -> None: ...
    def visit(self) -> list[Displayable]: ...

class RawStatement:
    constant: int | None
    loc: NodeLocation
    def __init__(self, loc: NodeLocation) -> None: ...
    def compile(self, ctx: Context) -> Statement: ...
    def predict(self, ctx: Context) -> None: ...
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class Statement(renpy.object.Object):
    loc: NodeLocation
    def __init__(self, loc: NodeLocation) -> None: ...
    def execute(
        self, trans: renpy.display.transform.ATLTransform, st: float, state: Any | None, events: list[str | None]
    ) -> (
        tuple[Literal["next"], float, float | None]
        | tuple[Literal["continue"], Any, float | None]
        | tuple[Literal["event"], tuple[str, float], float | None]
        | tuple[Literal["repeat"], tuple[int, float], float | None]
    ): ...
    def visit(self) -> list[Displayable]: ...
    def _handles_event(self, event: str) -> bool: ...

class RawBlock(RawStatement):
    animation: bool
    compiled_block: Block | None
    statements: list[RawStatement]
    def __init__(self, loc: NodeLocation, statements: list[RawStatement], animation: bool) -> None: ...
    def compile(self, ctx: Context) -> Block: ...
    def predict(self, ctx: Context) -> None: ...
    def analyze(self, parameters=None) -> None: ...
    constant: int | None
    def compile_block(self) -> None: ...
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class Block(Statement):
    statements: list[Statement]
    times: list[tuple[float, int]]
    def __init__(self, loc: NodeLocation, statements: list[Statement]) -> None: ...
    def _handles_event(self, event: str) -> bool: ...
    def execute(
        self, trans: ATLTransformBase, st: float, state: BlockState | None, events: list[str | None]
    ) -> (
        tuple[Literal["next"], float, None]
        | tuple[Literal["continue"], BlockState, float | None]
        | tuple[Literal["event"], tuple[str, float], float | None]
    ): ...
    def visit(self) -> list[Displayable]: ...

incompatible_props: dict[str, set[str]]
compatible_pairs: list[set[str]]

def check_spline_types(value: Any) -> bool: ...

class RawMultipurpose(RawStatement):
    warp_function: str | None
    warper: str | None
    duration: str | None
    properties: list[tuple[str, str]]
    expressions: list[tuple[str, str | None]]
    splines: list[tuple[str, list[str]]]
    revolution: Literal["clockwise", "counterclockwise", None]
    circles: str
    def __init__(self, loc: NodeLocation) -> None: ...
    def add_warper(self, name: str | None, duration: str | None, warp_function: str | None) -> None: ...
    def add_property(self, name: str, exprs: str) -> str | None: ...
    def add_expression(self, expr: str, with_clause: str | None) -> None: ...
    def add_revolution(self, revolution: Literal["clockwise", "counterclockwise", None]) -> None: ...
    def add_circles(self, circles: str) -> None: ...
    def add_spline(self, name: str, exprs: list[str]) -> None: ...
    def compile(self, ctx: Context) -> Statement: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...
    def predict(self, ctx: Context) -> None: ...

class RawContainsExpr(RawStatement):
    expression: str
    def __init__(self, loc: NodeLocation, expr: str) -> None: ...
    def compile(self, ctx: Context) -> Child: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class RawChild(RawStatement):
    children: list[RawBlock]
    def __init__(self, loc: NodeLocation, child: RawBlock) -> None: ...
    def compile(self, ctx: Context) -> Child: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class Child(Statement):
    child: Displayable
    transition: renpy.display.transition.TransitionFunction | None
    def __init__(
        self, loc: NodeLocation, child: Displayable, transition: renpy.display.transition.TransitionFunction | None
    ) -> None: ...
    def execute(
        self, trans: renpy.display.transform.ATLTransform, st: float, state: Any | None, events: list[str | None]
    ) -> tuple[Literal["next"], float, float | None]: ...
    def visit(self) -> list[Displayable | None]: ...

class Interpolation(Statement):
    warper: str | Warper
    duration: float
    properties: list[tuple[str, Any]]
    splines: list[tuple[str, list[str]]]
    revolution: Literal["clockwise", "counterclockwise", None]
    circles: int
    def __init__(
        self,
        loc: NodeLocation,
        warper: str | Warper,
        duration: float,
        properties: list[tuple[str, Any]],
        revolution: Literal["clockwise", "counterclockwise", None],
        circles: int,
        splines: list[tuple[str, list[str]]],
    ) -> None: ...
    def execute(
        self,
        trans: renpy.display.transform.ATLTransform,
        st: float,
        state: tuple[
            dict[str, tuple[Any, Any]],
            tuple[float, float] | None,
            tuple[Position, Position] | None,
            tuple[DualAngle, DualAngle],
            tuple[Position, Position] | None,
            list[tuple[str, list[Any]]] | None,
        ]
        | None,
        events: list[str | None],
    ) -> (
        tuple[Literal["next"], float, None]
        | tuple[
            Literal["continue"],
            tuple[
                dict[str, tuple[Any, Any]],
                tuple[float, float] | None,
                tuple[Position, Position] | None,
                tuple[DualAngle, DualAngle],
                tuple[Position, Position] | None,
                list[tuple[str, list[Any]]] | None,
            ],
            float,
        ]
    ): ...

class RawRepeat(RawStatement):
    repeats: str
    def __init__(self, loc: NodeLocation, repeats: str) -> None: ...
    def compile(self, ctx: Context) -> Statement: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class Repeat(Statement):
    repeats: int
    def __init__(self, loc: NodeLocation, repeats: int) -> None: ...
    def execute(
        self, trans: renpy.display.transform.ATLTransform, st: float, state: Any | None, events: list[str | None]
    ) -> tuple[Literal["repeat"], tuple[int, float], float | None]: ...

class RawParallel(RawStatement):
    blocks: list[RawBlock]
    def __init__(self, loc: NodeLocation, block: RawBlock) -> None: ...
    def compile(self, ctx: Context) -> Statement: ...
    def predict(self, ctx: Context) -> None: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class Parallel(Statement):
    blocks: list[Block]
    def __init__(self, loc: NodeLocation, blocks: list[Block]) -> None: ...
    def _handles_event(self, event: str) -> bool: ...
    def execute(
        self,
        trans: renpy.display.transform.ATLTransform,
        st: float,
        state: list[tuple[Block, BlockState]],
        events: list[str | None],
    ) -> (
        tuple[Literal["next"], float, float | None]
        | tuple[Literal["continue"], list[tuple[Block, BlockState]], float | None]
        | tuple[Literal["event"], tuple[str, float], float | None]
    ): ...
    def visit(self) -> list[Displayable]: ...

class RawChoice(RawStatement):
    choices: list[tuple[str, RawBlock]]
    def __init__(self, loc: NodeLocation, chance: str, block: RawBlock) -> None: ...
    def compile(self, ctx: Context) -> Statement: ...
    def predict(self, ctx: Context) -> None: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class Choice(Statement):
    choices: list[tuple[float, Block]]
    def __init__(self, loc: NodeLocation, choices: list[tuple[float, Block]]) -> None: ...
    def _handles_event(self, event: str) -> bool: ...
    def execute(
        self,
        trans: renpy.display.transform.ATLTransform,
        st: float,
        state: tuple[Block | None, Any] | None,
        events: list[str | None],
    ) -> (
        tuple[Literal["next"], float, None]
        | tuple[Literal["continue"], tuple[Block | None, Any], float | None]
        | tuple[Literal["event"], tuple[str, float], None]
    ): ...
    def visit(self) -> list[Displayable]: ...

class RawTime(RawStatement):
    time: str
    def __init__(self, loc: NodeLocation, time: str) -> None: ...
    def compile(self, ctx: Context) -> Statement: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class Time(Statement):
    time: float
    def __init__(self, loc: NodeLocation, time: float) -> None: ...
    def execute(
        self, trans: renpy.display.transform.ATLTransform, st: float, state: Any | None, events: list[str | None]
    ) -> tuple[Literal["continue"], None, None]: ...

class RawOn(RawStatement):
    handlers: dict[str, RawBlock]
    def __init__(self, loc: NodeLocation, names: list[str], block: RawBlock) -> None: ...
    def compile(self, ctx: Context) -> Statement: ...
    def predict(self, ctx: Context) -> None: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class On(Statement):
    handlers: dict[str, Block]
    def __init__(self, loc: NodeLocation, handlers: dict[str, Block]) -> None: ...
    def _handles_event(self, event: str) -> bool: ...
    def execute(
        self,
        trans: renpy.display.transform.ATLTransform,
        st: float,
        state: tuple[str, float, BlockState | None] | None,
        events: list[str | None],
    ) -> (
        tuple[Literal["continue"], tuple[str, float, BlockState | None], float | None]
        | tuple[Literal["event"], tuple[str, float], float | None]
    ): ...
    def visit(self) -> list[Displayable]: ...

class RawEvent(RawStatement):
    name: str
    def __init__(self, loc: NodeLocation, name: str) -> None: ...
    def compile(self, ctx: Context) -> Statement: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class Event(Statement):
    name: str
    def __init__(self, loc: NodeLocation, name: str) -> None: ...
    def execute(
        self, trans: renpy.display.transform.ATLTransform, st: float, state: Any | None, events: list[str | None]
    ) -> tuple[Literal["event"], tuple[str, float], None]: ...

class RawFunction(RawStatement):
    expr: str
    def __init__(self, loc: NodeLocation, expr: str) -> None: ...
    def compile(self, ctx: Context) -> Statement: ...
    constant: int | None
    def mark_constant(self, analysis: renpy.pyanalysis.Analysis) -> None: ...

class Function(Statement):
    function: Callable[[renpy.display.transform.ATLTransform, float, float], float | None]
    def __init__(
        self, loc: NodeLocation, function: Callable[[renpy.display.transform.ATLTransform, float, float], float | None]
    ) -> None: ...
    def _handles_event(self, event: str) -> bool: ...
    def execute(
        self, trans: renpy.display.transform.ATLTransform, st: float, state: bool | None, events: list[str | None]
    ) -> tuple[Literal["next"], float, None] | tuple[Literal["continue"], bool, float | None]: ...

def parse_atl(l: Lexer) -> RawBlock: ...
def deep_compare(a: Any, b: Any) -> bool: ...
