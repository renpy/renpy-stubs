import ast
import builtins
import renpy
from _typeshed import Incomplete as Incomplete
from renpy.compat.pickle import dumps as dumps, loads as loads
from renpy.python import py_compile as py_compile
from typing import Generator, Sequence

always_constants: set[str]
pure_functions: set[str]
constants: set[str]
not_constants: set[str]
local_constants: set[str]

def const(name: str) -> None: ...
def not_const(name: str) -> None: ...
def pure(fn: str | builtins.function) -> str | builtins.function: ...
def import_from(from_module_name: str, in_module_name: str, *names: tuple[str, str]) -> None: ...

class Control:
    const: bool
    loop: bool
    imagemap: bool
    def __init__(self, const: bool, loop: bool, imagemap: bool) -> None: ...
    def __repr__(self) -> str: ...

GLOBAL_CONST: int
LOCAL_CONST: int
NOT_CONST: int

class DeltaSet:
    base: set[str]
    added: set[str | None]
    removed: set[str | None]
    changed: bool
    def __init__(self, base: set[str], copy: DeltaSet | None = None) -> None: ...
    def add(self, v: str | None) -> None: ...
    def discard(self, v: str | None) -> None: ...
    def __contains__(self, v: str | None) -> bool: ...
    def copy(self) -> DeltaSet: ...
    def __iter__(self) -> Generator[str, None, None]: ...

class Analysis:
    parent: Analysis | None
    children: dict[Incomplete, "Analysis"]
    not_constant: DeltaSet
    local_constant: DeltaSet
    global_constant: DeltaSet
    pure_functions: DeltaSet
    control: Control
    control_stack: list[Control]
    def __init__(self, parent: Analysis | None = None) -> None: ...
    def get_child(self, identifier: Incomplete) -> Analysis: ...
    def push_control(self, const: bool | int = True, loop: bool = False, imagemap: bool = False) -> None: ...
    def pop_control(self) -> Control: ...
    def imagemap(self) -> int: ...
    def exit_loop(self) -> None: ...
    def at_fixed_point(self) -> bool: ...
    def mark_constant(self, name: str) -> None: ...
    def mark_not_constant(self, name: str) -> None: ...
    def _check_name(self, node: ast.AST) -> tuple[int, str | None]: ...
    def _check_nodes(self, nodes: Sequence[ast.AST | None]) -> int: ...
    def _check_node(self, node: ast.AST | None) -> int: ...
    def is_constant(self, node: ast.AST | None) -> int: ...
    def is_constant_expr(self, expr: renpy.ast.PyExpr) -> int: ...
    def python(self, code: renpy.ast.PyExpr | str) -> None: ...
    def parameters(self, parameters: renpy.parameter.ParameterInfo) -> None: ...

class PyAnalysis(ast.NodeVisitor):
    analysis: Analysis
    def __init__(self, analysis: Analysis) -> None: ...
    def visit_Name(self, node: ast.Name) -> None: ...
    def visit_NamedExpr(self, node: ast.NamedExpr) -> None: ...
    def visit_FunctionDef(self, node: ast.FunctionDef) -> None: ...
    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> None: ...
    def visit_ClassDef(self, node: ast.ClassDef) -> None: ...
    def visit_Assign(self, node: ast.Assign) -> None: ...
    def visit_AugAssign(self, node: ast.AugAssign) -> None: ...
    def visit_AnnAssign(self, node: ast.AnnAssign) -> None: ...
    def visit_For(self, node: ast.For | ast.AsyncFor) -> None: ...
    def visit_AsyncFor(self, node: ast.AsyncFor) -> None: ...
    def visit_While(self, node: ast.While) -> None: ...
    def visit_If(self, node: ast.If) -> None: ...
    def visit_withitem(self, node: ast.withitem) -> None: ...
    def visit_MatchMapping(self, node: ast.MatchMapping) -> None: ...
    def visit_MatchStar(self, node: ast.MatchStar) -> None: ...
    def visit_MatchAs(self, node: ast.MatchAs) -> None: ...
    def visit_Try(self, node: ast.Try) -> None: ...
    def visit_Break(self, node: ast.Break) -> None: ...
    def visit_Continue(self, node: ast.Continue) -> None: ...

class CompilerCache:
    ast_eval_cache: dict[tuple[renpy.ast.PyExpr | str, str | None, int | None], tuple[ast.AST, bool]]
    ast_exec_cache: dict[tuple[renpy.ast.PyExpr | str, str | None, int | None], list[ast.AST]]
    updated: bool
    version: int
    def __init__(self) -> None: ...
    def ast_eval_literal(self, expr: renpy.ast.PyExpr | str) -> tuple[ast.AST, bool]: ...
    def ast_eval(self, expr: renpy.ast.PyExpr | str) -> ast.AST: ...
    def ast_exec(self, code: renpy.ast.PyExpr | str) -> list[ast.AST]: ...

ccache: CompilerCache
new_ccache: CompilerCache
CACHE_FILENAME: str

def load_cache() -> None: ...
def save_cache() -> None: ...
