import renpy
from _typeshed import Incomplete as Incomplete
from collections import defaultdict
from collections.abc import Iterable
from renpy.atl import RawBlock as RawBlock, parse_atl as parse_atl
from renpy.display.transform import ATLTransform as ATLTransform
from renpy.object import Object as Object
from store import Transform
from typing import Container, Literal

python_object = object
type Imageable = RawBlock | str | None
ATL_PROPERTIES: Incomplete
FIXED_PROPERTIES: Incomplete
BASE_PROPERTIES: Incomplete
LAYER_PROPERTIES: Incomplete
ATTRIBUTE_PROPERTIES: Incomplete
GROUP_BLOCK_PROPERTIES: Incomplete
GROUP_INLINE_PROPERTIES: Incomplete
CONDITION_PROPERTIES = LAYER_PROPERTIES
ALWAYS_PROPERTIES = LAYER_PROPERTIES
predict_all: Incomplete

def format_function(what, name, group, variant, attribute, image, image_format, **kwargs): ...
def resolve_image(img: Imageable): ...
def resolve_at(at: RawBlock | Transform | Iterable[Transform]) -> tuple[Transform, ...]: ...

class When(python_object):
    def __init__(self) -> None: ...
    def check(self, attributes: set[str]) -> bool: ...
    @staticmethod
    def parse(l) -> When: ...

class WhenOr(When):
    left: Incomplete
    right: Incomplete
    def __init__(self, left, right, /) -> None: ...
    def check(self, attributes): ...
    @staticmethod
    def parse(l) -> When: ...

class WhenAnd(When):
    left: Incomplete
    right: Incomplete
    def __init__(self, left, right, /) -> None: ...
    def check(self, attributes): ...
    @staticmethod
    def parse(l) -> When: ...

class WhenNot(When):
    when: Incomplete
    def __init__(self, when, /) -> None: ...
    def check(self, attributes): ...
    @staticmethod
    def parse(l) -> When: ...

class WhenAttribute(When):
    attribute: Incomplete
    def __init__(self, attribute, /) -> None: ...
    def check(self, attributes): ...
    @staticmethod
    def parse(l) -> When: ...

class Layer:
    group_args: Incomplete
    at: Incomplete
    when: Incomplete
    if_all: Incomplete
    if_any: Incomplete
    if_not: Incomplete
    transform_args: Incomplete
    def __init__(
        self, if_all=[], if_any=[], if_not=[], at=(), group_args={}, *, when: When | str | None = None, **kwargs
    ) -> None: ...
    def check(self, attributes): ...
    def wrap(self, d): ...
    def apply_format(self, li: LayeredImage, /): ...
    def get_displayable(self, attributes) -> None: ...

class Attribute(Layer):
    group: Incomplete
    raw_attribute: Incomplete
    attribute: Incomplete
    image: Incomplete
    default: Incomplete
    variant: Incomplete
    def __init__(
        self, group, attribute, image=None, default: bool = False, *, prefix=None, variant=None, **kwargs
    ) -> None: ...
    def apply_format(self, li: LayeredImage): ...
    def get_displayable(self, attributes): ...

class Condition(Layer):
    at: Incomplete
    condition: Incomplete
    image: Incomplete
    def __init__(self, condition, image, **kwargs) -> None: ...
    def apply_format(self, li: LayeredImage): ...
    def get_displayable(self, attributes): ...

class ConditionGroup(Layer):
    conditions: Incomplete
    def __init__(self, conditions) -> None: ...
    def apply_format(self, li: LayeredImage): ...
    def get_displayable(self, attributes): ...

class Always(Layer):
    image: Incomplete
    def __init__(self, image, **kwargs) -> None: ...
    def apply_format(self, li: LayeredImage): ...
    def get_displayable(self, attributes): ...

class LayeredImage:
    attribute_function: Incomplete
    transform_args: Incomplete
    offer_screen: Incomplete
    name: Incomplete
    image_format: Incomplete
    format_function: Incomplete
    attributes: list[Attribute]
    layers: list[Layer]
    attribute_to_groups: defaultdict[str, set[str]]
    group_to_attributes: defaultdict[str, set[str]]
    at: Incomplete
    fixed_args: Incomplete
    def __init__(
        self,
        attributes,
        at=[],
        name=None,
        image_format=None,
        format_function=...,
        attribute_function=None,
        offer_screen=None,
        **kwargs,
    ) -> None: ...
    def format(self, what, attribute=None, group=None, variant=None, image=None): ...
    def add(self, a) -> None: ...
    def get_banned(self, attributes): ...

def parse_property(
    l, final_properties: dict, expr_properties: dict, names: Container[str]
) -> Literal[0] | Literal[1] | Literal[2]: ...
def parse_displayable(l) -> Imageable: ...

class RawAttribute(renpy.object.Object):
    __version__: int
    expr_properties: Incomplete
    final_properties: Incomplete
    def after_upgrade(self, version: int): ...
    name: Incomplete
    image: Imageable
    def __init__(self, name) -> None: ...
    def execute(self, group_name=None, **group_properties): ...

def parse_attribute(l): ...

class RawAttributeGroup(renpy.object.Object):
    __version__: int
    expr_properties: Incomplete
    final_properties: Incomplete
    group_name: Incomplete
    li_name: Incomplete
    def after_upgrade(self, version: int): ...
    children: Incomplete
    def __init__(self, li_name, group_name: str | None) -> None: ...
    def execute(self): ...

def parse_group(l, li_name): ...

class RawCondition(renpy.object.Object):
    __version__: int
    expr_properties: Incomplete
    final_properties: Incomplete
    def after_upgrade(self, version: int): ...
    condition: Incomplete
    image: Imageable
    def __init__(self, condition) -> None: ...
    def execute(self): ...

def parse_condition(l, need_expr): ...

class RawConditionGroup:
    conditions: Incomplete
    def __init__(self, conditions: list | tuple = ()) -> None: ...
    def execute(self): ...

def parse_conditions(l): ...

class RawAlways(renpy.object.Object):
    __version__: int
    expr_properties: Incomplete
    final_properties: Incomplete
    def after_upgrade(self, version: int): ...
    image: Imageable
    def __init__(self) -> None: ...
    def execute(self): ...

def parse_always(l): ...

class RawLayeredImage(renpy.object.Object):
    __version__: int
    expr_properties: Incomplete
    final_properties: Incomplete
    def after_upgrade(self, version: int): ...
    name: Incomplete
    children: list[RawAlways | RawAttribute | RawAttributeGroup | RawConditionGroup]
    def __init__(self, name) -> None: ...
    def execute(self) -> None: ...

def execute_layeredimage(rai) -> None: ...
def parse_layeredimage(l): ...
def lint_layeredimage(rli: RawLayeredImage) -> None: ...

class LayeredImageProxy:
    name: Incomplete
    transform: Incomplete
    def __init__(self, name, transform=None) -> None: ...
    @property
    def image(self): ...
    def filter_attributes(self, attributes): ...
