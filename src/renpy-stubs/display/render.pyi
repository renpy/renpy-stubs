from typing import Any, Callable

import renpy

import collections as collections
import gc as gc
import math as math
import renpy.pygame as pygame
import renpy as renpy
import threading as threading

class Canvas:
    def __init__(self, surf): ...
    def aaline(self, color, startpos, endpos, blend=1): ...
    def aalines(self, color, closed, pointlist, blend=1): ...
    def arc(self, color, rect, start_angle, stop_angle, width=1): ...
    def circle(self, color, pos, radius, width=0): ...
    def ellipse(self, color, rect, width=0): ...
    def get_surface(self): ...
    def line(self, color, start_pos, end_pos, width=1): ...
    def lines(self, color, closed, pointlist, width=1): ...
    def polygon(self, color, pointlist, width=0): ...
    def rect(self, color, rect, width=0): ...

Matrix = renpy.display.matrix.Matrix

Matrix2D = renpy.display.matrix.Matrix2D

class Render:
    def __init__(self, width: float, height: float, layer_name=None): ...
    def __getstate__(self): ...
    def __repr__(self, /): ...
    def __setstate__(self, state): ...
    def absolute_blit(self, source, pos: tuple, focus=True, main=True, index=None) -> int: ...
    def add_focus(self, d, arg=None, x=0, y=0, w=None, h=None, mx=None, my=None, mask=None): ...
    def add_property(self, name, value): ...
    def add_shader(self, shader): ...
    def add_uniform(self, name, value): ...
    def blit(self, source, pos: tuple, focus=True, main=True, index=None) -> int: ...
    def canvas(self): ...
    def compute_subline(self, sx, sw, cx, cw, bx, bw): ...
    def depends_on(self, source, focus=False): ...
    def fill(self, color): ...
    def focus_at_point(self, x, y, screen): ...
    def get_property(self, name, default): ...
    def get_size(self): ...
    def is_fully_transparent(self): ...
    def is_pixel_opaque(self, x, y): ...
    def kill(self): ...
    def kill_cache(self): ...
    def main_displayables_at_point(self, x, y, layers, depth=None): ...
    def place(self, d, x=0, y=0, width=None, height=None, st=None, at=None, render=None, main=True): ...
    def pygame_surface(self, alpha=True): ...
    def render_to_texture(self, alpha=True): ...
    def screen_rect(self, sx: float, sy: float, transform: "Matrix"): ...
    def subpixel_blit(self, source, pos: tuple, focus=True, main=True, index=None) -> int: ...
    def subsurface(self, rect, focus=False, subpixel=False, bounds=None): ...
    def take_focuses(self, cminx, cminy, cmaxx, cmaxy, transform, screen, focuses): ...
    def zoom(self, xzoom, yzoom): ...

    mark: bool
    cache_killed: bool
    killed: bool
    width: int
    height: int
    layer_name: str
    children: "list[tuple[Render, int, int, bool, bool]]"
    forward: "renpy.display.matrix.Matrix"
    reverse: "renpy.display.matrix.Matrix"
    alpha: float
    over: float
    nearest: bool
    focuses: "list[renpy.display.focus.Focus]"
    pass_focuses: "list[Render]"
    focus_screen: "renpy.display.screen.ScreenDisplayable"
    render_of: "list[renpy.display.core.Displayable]"
    xclipping: bool
    yclipping: bool
    modal: bool
    text_input: bool
    parents: "set[Render]"
    depends_on_list: "list[Render]"
    operation: int
    operation_complete: float
    operation_alpha: bool
    operation_parameter: float
    surface: "Any"
    alpha_surface: "Any"
    half_cache: "Any"
    mesh: "Any"
    shaders: tuple
    uniforms: dict
    properties: dict
    cached_texture: "Any"
    cached_model: "Any"
    loaded: bool
    uniforms_has_render: bool

def adjust_render_cache_times(old_time, new_time): ...
def check_at_shutdown(): ...
def check_redraws(): ...
def focus_at_point(x, y): ...
def free_memory(): ...
def invalidate(d): ...
def mark_sweep(): ...
def mutated_surface(surf): ...
def process_redraws(): ...
def redraw(d, when): ...
def redraw_time(): ...
def render(d, widtho, heighto, st: float, at: float): ...
def render_for_size(d, width, height, st, at): ...
def render_ready(): ...
def render_screen(root, width, height): ...
def take_focuses(focuses): ...

screen_render: "Render | None"
IDENTITY: "renpy.display.matrix.Matrix"
blit_lock: "threading.Condition"
BLIT: int
DISSOLVE: int
FLATTEN: int
IMAGEDISSOLVE: int
PIXELLATE: int
models: int
per_frame: int
render_height: int
render_width: int
sizing: int
