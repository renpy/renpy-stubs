import renpy
from concurrent.futures import ThreadPoolExecutor
import threading
from renpy.color import ColorLike as ColorLike
from renpy.display.displayable import Displayable as Displayable, Placement as Placement
from renpy.display.image import ImageReference as ImageReference
from renpy.display.render import Render as Render
from renpy.pygame.surface import Surface as Surface
from renpy.types import Unused as Unused
from typing import Any, Literal, TypeVar, overload

T = TypeVar("T")
type ImageLikeBase = ImageBase | str | ImageReference
type ImageLike = ImageLikeBase | tuple[ImageLikeBase, ...]

class CacheEntry:
    what: ImageBase
    surf: Surface | None
    texture: Surface | None
    bounds: tuple[int, int, int, int]
    time: int
    def __init__(self, what: ImageBase, surf: Surface, bounds: tuple[int, int, int, int]) -> None: ...
    def size(self) -> int: ...

class Cache:
    time: int
    cache: dict[ImageBase, CacheEntry]
    cache_size: int
    preloads: list[ImageBase]
    first_preload_in_tick: bool
    lock: threading.Condition
    preload_lock: threading.Condition
    keep_preloading: bool
    preload_blacklist: set[ImageBase]
    cache_limit: int
    in_preload_pass: bool
    preload_thread: threading.Thread | None
    decode_pool: ThreadPoolExecutor | None
    decode_pool_workers: int
    added: set[ImageBase]
    load_log: list[tuple[float, str, bool]]
    def __init__(self) -> None: ...
    def done(self) -> bool: ...
    def get_total_size(self) -> int: ...
    def get_current_size(self, generations: int) -> int: ...
    def init(self) -> None: ...
    def quit(self) -> None: ...
    def clear(self) -> None: ...
    def clear_variable_size(self) -> None: ...
    def get_renders(self) -> list[Render]: ...
    def tick(self) -> None: ...
    def end_tick(self) -> None: ...
    @staticmethod
    def _make_render(ce: CacheEntry) -> Render: ...
    @overload
    def get(
        self, image: ImageBase, *, predict: Literal[True], texture: Literal[True], render: Literal[True]
    ) -> None: ...
    @overload
    def get(
        self, image: ImageBase, *, predict: Literal[True], texture: Literal[False] = ..., render: Literal[True]
    ) -> None: ...
    @overload
    def get(
        self, image: ImageBase, *, predict: Literal[True], texture: Literal[True], render: Literal[False] = ...
    ) -> None: ...
    @overload
    def get(
        self, image: ImageBase, *, predict: Literal[True], texture: Literal[False] = ..., render: Literal[False] = ...
    ) -> Surface: ...
    @overload
    def get(
        self, image: ImageBase, *, predict: Literal[False] = ..., texture: Literal[True], render: Literal[True]
    ) -> Render: ...
    @overload
    def get(
        self, image: ImageBase, *, predict: Literal[False] = ..., texture: Literal[False] = ..., render: Literal[True]
    ) -> Render: ...
    @overload
    def get(
        self, image: ImageBase, *, predict: Literal[False] = ..., texture: Literal[True], render: Literal[False] = ...
    ) -> Surface: ...
    @overload
    def get(
        self,
        image: ImageBase,
        *,
        predict: Literal[False] = ...,
        texture: Literal[False] = ...,
        render: Literal[False] = ...,
    ) -> Surface: ...
    def kill(self, ce: CacheEntry) -> None: ...
    def cleanout(self) -> bool: ...
    def flush_file(self, fn: str) -> None: ...
    def preload_texture(self, im: ImageBase) -> None: ...
    def get_texture(self, im: ImageBase) -> None: ...
    def preload_image(self, im: ImageBase) -> None: ...
    def start_prediction(self) -> None: ...
    def get_decode_pool(self) -> ThreadPoolExecutor | None: ...
    def preload_thread_main(self) -> None: ...
    def preload_thread_pass(self) -> None: ...
    def _preload_thread_pass_serial(self) -> None: ...
    def _preload_thread_pass_parallel(self, pool: ThreadPoolExecutor) -> None: ...
    def add_load_log(self, filename: str) -> None: ...

cache: Cache

def free_memory() -> None: ...

class ImageBase(Displayable):
    __version__: int
    optimize_bounds: bool
    oversample: int | None
    pixel_perfect: bool
    obsolete: bool
    obsolete_list: list[tuple[str, int, str]]
    mipmap: Literal["auto", True, False, None]
    fail: Displayable | None
    const_size: bool
    cache: bool
    def after_upgrade(self, version) -> None: ...
    rle: Unused
    identity: tuple[str | Any]
    def __init__(self, *args, **properties) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def load(self) -> Surface: ...
    def render(self, w: float, h: float, st: float, at: float) -> Render: ...
    def get_placement(self) -> Placement: ...
    def predict_one(self) -> None: ...
    def predict_files(self) -> list[str]: ...
    def get_hash(self) -> int: ...
    def get_oversample(self) -> int: ...
    def get_oversampled_image(self) -> ImageBase: ...

ignored_images: set[str]
images_to_ignore: set[str]

class Image(ImageBase):
    obsolete: bool
    is_svg: bool
    dpi: int
    filename: str
    pixel_perfect: bool
    const_size: bool
    def __init__(self, filename: str, dpi: int = 96, **properties) -> None: ...
    def get_oversampled_image(self) -> Image: ...
    def _repr_info(self) -> str: ...
    def get_hash(self) -> int: ...
    def get_oversample(self) -> int: ...
    def load(self, unscaled: bool = False) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class Data(ImageBase):
    obsolete: bool
    data: bytes
    filename: str
    const_size: bool
    def __init__(self, data: bytes, filename: str, **properties) -> None: ...
    def _repr_info(self) -> str: ...
    def load(self) -> Surface: ...

class ZipFileImage(ImageBase):
    obsolete: bool
    zipfilename: str
    filename: str
    const_size: bool
    def __init__(self, zipfilename: str, filename: str, mtime: int = 0, **properties) -> None: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class Null(ImageBase):
    obsolete: float
    color: tuple[int, int, int, int]
    const_size: bool
    def __init__(self, color: ColorLike = (0, 0, 0, 0), **properties) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class UnoptimizedTexture(ImageBase):
    obsolete: bool
    image: ImageBase
    const_size: bool
    def __init__(self, im: ImageLike, **properties) -> None: ...
    def _repr_info(self) -> str: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

@overload
def image(arg: ImageBase, loose: Literal[False] = ..., **properties) -> ImageBase: ...
@overload
def image(arg: str, loose: Literal[False] = ..., **properties) -> Image: ...
@overload
def image(arg: ImageReference, loose: Literal[False] = ..., **properties) -> ImageBase: ...
@overload
def image(arg: tuple[ImageLike, ...], loose: Literal[False] = ..., **properties) -> Composite: ...
@overload
def image(arg: T, loose: Literal[True], **properties) -> T: ...
def expand_bounds(
    bounds: tuple[int, int, int, int], size: tuple[int, int], amount: int
) -> tuple[int, int, int, int]: ...
def ensure_bounds_divide_evenly(bounds: tuple[int, int, int, int], n: int) -> tuple[int, int, int, int]: ...
def load_image(im) -> Render: ...
def load_surface(im) -> Surface: ...
def load_rgba(data: bytes, size: tuple[int, int]) -> Surface: ...
@overload
def unoptimized_texture(d: ImageBase) -> UnoptimizedTexture: ...
@overload
def unoptimized_texture(d: T) -> T: ...
def render_for_texture(d: Displayable, width: float, height: float, st: float, at: float) -> Render: ...
def reset_module() -> None: ...

class Composite(ImageBase):
    size: tuple[int, int] | None
    positions: list[tuple[int, int]]
    images: list[ImageBase]
    oversample: int
    const_size: bool
    def __init__(self, size: tuple[int, int] | None, *args, **properties) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class Scale(ImageBase):
    image: ImageBase
    oversample: int
    width: int
    height: int
    bilinear: bool
    const_size: bool
    def __init__(self, im: ImageLike, width: int, height: int, bilinear: bool = True, **properties) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class FactorScale(ImageBase):
    image: ImageBase
    oversample: int
    width: float
    height: float
    bilinear: bool
    const_size: bool
    def __init__(
        self, im: ImageLike, width: float, height: float | None = None, bilinear: bool = True, **properties
    ) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class Flip(ImageBase):
    image: ImageBase
    oversample: int
    horizontal: bool
    vertical: bool
    const_size: bool
    def __init__(self, im: ImageLike, horizontal: bool = False, vertical: bool = False, **properties) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class Rotozoom(ImageBase):
    image: ImageBase
    oversample: int
    angle: float
    zoom: float
    const_size: bool
    def __init__(self, im: ImageLike, angle: float, zoom: float, **properties) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class Crop(ImageBase):
    @overload
    def __init__(self, im: ImageLike, x: int, y: int, w: int, h: int, **properties) -> None: ...
    @overload
    def __init__(
        self,
        im: ImageLike,
        x: tuple[int, int, int, int],
        y: None = None,
        w: None = None,
        h: None = None,
        **properties,
    ) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

ramp_cache: dict[tuple[int, int], bytes]

def ramp(start: int, end: int) -> bytes: ...

identity: bytes

class Map(ImageBase):
    image: ImageBase
    oversample: int
    rmap: bytes
    gmap: bytes
    bmap: bytes
    amap: bytes
    force_alpha: bool
    const_size: bool
    def __init__(
        self,
        im: ImageLike,
        rmap: bytes = ...,
        gmap: bytes = ...,
        bmap: bytes = ...,
        amap: bytes = ...,
        force_alpha: bool = False,
        **properties,
    ) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class Twocolor(ImageBase):
    image: ImageBase
    oversample: int
    white: renpy.color.Color
    black: renpy.color.Color
    force_alpha: bool
    def __init__(
        self, im: ImageLike, white: ColorLike, black: ColorLike, force_alpha: bool = False, **properties
    ) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class Recolor(ImageBase):
    image: ImageBase
    oversample: int
    rmul: int
    gmul: int
    bmul: int
    amul: int
    force_alpha: bool
    const_size: bool
    def __init__(
        self,
        im: ImageLike,
        rmul: int = 255,
        gmul: int = 255,
        bmul: int = 255,
        amul: int = 255,
        force_alpha: bool = False,
        **properties,
    ) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class Blur(ImageBase):
    image: ImageBase
    oversample: int
    rx: float
    ry: float
    const_size: bool
    def __init__(self, im: ImageLike, xrad: float, yrad: float | None = None, **properties) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class MatrixColor(ImageBase):
    image: ImageBase
    oversample: int
    matrix: tuple[float, ...]
    const_size: bool
    def __init__(self, im: ImageLike, matrix: list[float] | tuple[float, ...] | matrix, **properties) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class matrix(tuple):
    def __new__(cls, *args): ...
    def mul(
        self, a: matrix | list[float] | tuple[float, ...], b: matrix | list[float] | tuple[float, ...]
    ) -> matrix: ...
    def scalar_mul(self, other: float) -> matrix: ...
    def vector_mul(self, o: tuple[float, float, float, float]) -> tuple[float, float, float, float, float]: ...
    def __add__(self, other: matrix | list[float] | tuple[float, ...] | int | float) -> matrix: ...
    __radd__ = __add__
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    @overload
    def __mul__(self, other: renpy.color.Color) -> renpy.color.Color: ...
    @overload
    def __mul__(self, other: matrix | list[float] | tuple[float, ...] | int | float) -> matrix: ...
    @overload
    def __rmul__(self, other: renpy.color.Color) -> renpy.color.Color: ...
    @overload
    def __rmul__(self, other: matrix | list[float] | tuple[float, ...] | int | float) -> matrix: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def identity() -> matrix: ...
    @staticmethod
    def saturation(level: float, desat: tuple[float, float, float] = (0.2126, 0.7152, 0.0722)) -> matrix: ...
    @staticmethod
    def desaturate() -> matrix: ...
    @staticmethod
    def tint(r: float, g: float, b: float) -> matrix: ...
    @staticmethod
    def invert() -> matrix: ...
    @staticmethod
    def brightness(b: float) -> matrix: ...
    @staticmethod
    def opacity(o: float) -> matrix: ...
    @staticmethod
    def contrast(c: float) -> matrix: ...
    @staticmethod
    def hue(h: float) -> matrix: ...
    @staticmethod
    def colorize(black_color: ColorLike, white_color: ColorLike) -> matrix: ...

def Grayscale(
    im: ImageLike, desat: tuple[float, float, float] = (0.2126, 0.7152, 0.0722), **properties
) -> MatrixColor: ...
def Sepia(
    im: ImageLike,
    tint: tuple[float, float, float] = (1.0, 0.94, 0.76),
    desat: tuple[float, float, float] = (0.2126, 0.7152, 0.0722),
    **properties,
) -> MatrixColor: ...
def Color(im: ImageLike, color: ColorLike) -> Recolor: ...
def Alpha(image: ImageLike, alpha: float, **properties) -> Recolor: ...

class Tile(ImageBase):
    image: ImageBase
    oversample: int
    size: tuple[int, int] | None
    const_size: bool
    def __init__(self, im: ImageLike, size: tuple[int, int] | None = None, **properties) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...

class AlphaMask(ImageBase):
    base: ImageBase
    mask: ImageBase
    oversample: int
    const_size: bool
    def __init__(self, base: ImageLike, mask: ImageLike, **properties) -> None: ...
    def get_hash(self) -> int: ...
    def load(self) -> Surface: ...
    def predict_files(self) -> list[str]: ...
