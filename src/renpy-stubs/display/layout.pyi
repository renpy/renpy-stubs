import renpy
import types
from _typeshed import Incomplete as Incomplete
from renpy.display.displayable import (
    Displayable as Displayable,
    Placement as Placement,
    DisplayableArguments as DisplayableArguments,
)
from renpy.display.render import Render as Render, render as render
from renpy.types import DisplayableLike as DisplayableLike
from types import CodeType
from typing import Any, Callable, Literal, Self

compute_raw: Incomplete

def xyminimums(style: renpy.style.Style, width: float, height: float) -> tuple[float, float]: ...

class Null(renpy.display.displayable.Displayable):
    width: float
    height: float
    def __init__(self, width: float = 0, height: float = 0, **properties) -> None: ...
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...

class Container(renpy.display.displayable.Displayable):
    _list_type = list
    children: list[Displayable]
    child: Displayable | None
    offsets: list[tuple[float, float]]
    def __init__(self, *args: Displayable, **properties) -> None: ...
    def set_transform_event(self, event: str): ...
    def _handles_event(self, event: str) -> bool: ...
    def set_style_prefix(self, prefix: str, root: bool) -> None: ...
    def _duplicate(self, args: DisplayableArguments | None) -> Self: ...
    _duplicatable: bool
    def _unique(self) -> None: ...
    def _in_current_store(self) -> Self: ...
    def add(self, d: DisplayableLike) -> None: ...
    def _clear(self) -> None: ...
    def remove(self, d: Displayable) -> None: ...
    def update(self) -> None: ...
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...
    def event(self, ev: renpy.pygame.event.EventType, x: float, y: float, st: float) -> Any | None: ...
    def visit(self): ...
    def __enter__(self): ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None
    ): ...

def Composite(size: tuple[float, float], *args, **properties) -> MultiBox: ...

LiveComposite = Composite

class Position(Container):
    def __init__(self, child: DisplayableLike, style: str = "image_placement", **properties) -> None: ...
    offsets: list[tuple[float, float]]
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...
    def get_placement(self): ...

class Grid(Container):
    allow_underfull: bool | None
    gridmap: list[tuple[int, int]] | None
    cols: int
    rows: int
    transpose: bool
    right_to_left: bool
    bottom_to_top: bool
    def __init__(
        self,
        cols: int,
        rows: int,
        padding: int | None = None,
        transpose: bool = False,
        style: str = "grid",
        allow_underfull: bool | None = None,
        *,
        right_to_left: bool = False,
        bottom_to_top: bool = False,
        **properties,
    ) -> None: ...
    offsets: list[tuple[float, float]]
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...
    def add(self, d: DisplayableLike) -> None: ...
    def per_interact(self) -> None: ...
    def generate_gridmap(self) -> list[tuple[int, int]]: ...

class IgnoreLayers(Exception): ...

def default_modal_function(
    ev: renpy.pygame.event.EventType | None, x: float, y: float, w: float | None, h: float | None
) -> bool: ...
def check_modal(
    modal: bool | Callable[[renpy.pygame.event.EventType | None, float, float, float | None, float | None], bool],
    ev: renpy.pygame.event.EventType | None,
    x: float,
    y: float,
    w: float | None,
    h: float | None,
) -> bool: ...

class MultiBox(Container):
    layer_name: str | None
    first: bool
    order_reverse: bool
    layout: Incomplete | None
    _layer_at_list: Incomplete | None
    _camera_list: Incomplete | None
    layers: dict[str, MultiBox] | None
    untransformed_layer: Incomplete | None
    adjust_times: bool
    _clipping: bool
    default_layout: str | None
    start_times: list[float | None]
    anim_times: list[float | None]
    scene_list: list[renpy.display.scenelists.SceneListEntry] | None
    def __init__(
        self, spacing: int | None = None, layout: str | None = None, style: str = "default", **properties
    ) -> None: ...
    def _clear(self) -> None: ...
    def _in_current_store(self) -> Self: ...
    def _classname(self) -> str: ...
    def __repr__(self) -> str: ...
    def add(self, widget: Displayable, start_time: float | None = None, anim_time: float | None = None) -> None: ...
    def append_scene_list(self, l: list[renpy.display.scenelists.SceneListEntry]) -> None: ...
    def update_times(self) -> None: ...
    offsets: list[tuple[float, float]]
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...
    def event(self, ev, x, y, st): ...
    def _tts(self, raw: bool) -> str: ...

def Fixed(**properties) -> MultiBox: ...

class SizeGroup(renpy.object.Object):
    members: list[Displayable]
    _width: int | None
    computing_width: bool
    def __init__(self) -> None: ...
    def width(self, width: int, height: int, st: float, at: float) -> int: ...

size_groups: Incomplete

class Window(Container):
    window_size: tuple[float, float]
    current_child: Displayable | None
    def __init__(self, child: DisplayableLike | None = None, style: str = "window", **properties) -> None: ...
    def visit(self) -> list[Displayable]: ...
    def get_child(self) -> Displayable | None: ...
    def per_interact(self) -> None: ...
    offsets: Incomplete
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...
    def event(self, ev, x, y, st): ...

def dynamic_displayable_compat(st: float, at: float, expr: str) -> tuple[Displayable, None]: ...

class DynamicDisplayable(renpy.display.displayable.Displayable):
    nosave: Incomplete
    _duplicatable: bool
    raw_child: Displayable | None
    last_st: float
    last_at: float
    child: Incomplete
    def after_setstate(self) -> None: ...
    predict_function: Incomplete
    function: Incomplete
    args: Incomplete
    kwargs: Incomplete
    def __init__(
        self, function: Callable[[float, float, Any], tuple[Displayable, float | None]], *args, **kwargs
    ) -> None: ...
    def _duplicate(self, args: DisplayableArguments | None) -> Self: ...
    def visit(self) -> list[Displayable]: ...
    def update(self, st: float, at: float) -> None: ...
    def per_interact(self) -> None: ...
    def render(self, w, h, st, at): ...
    def predict_one(self) -> None: ...
    def get_placement(self) -> Placement | None: ...
    def event(self, ev, x, y, st): ...

cond_cache: dict[str, CodeType]

def condition_switch_pick(switch: list[tuple[str, Displayable]]) -> Displayable: ...
def condition_switch_show(
    st: float, at: float, switch: list[tuple[str, Displayable]], predict_all: bool | None = None
) -> tuple[Displayable, None]: ...
def condition_switch_predict(
    switch: list[tuple[str, Displayable]], predict_all: bool | None = None
) -> list[Displayable]: ...
def ConditionSwitch(*args, **kwargs) -> Position: ...
def ShowingSwitch(*args, **kwargs) -> Position: ...

class IgnoresEvents(Container):
    def __init__(self, child: DisplayableLike, **properties) -> None: ...
    def render(self, w, h, st, at): ...
    def get_placement(self): ...
    def event(self, ev, x, y, st) -> None: ...

def Crop(rect: tuple[float, float, float, float], child: Displayable, **properties): ...

LiveCrop = Crop

class Side(Container):
    possible_positions: set[str]
    sized: bool
    def after_setstate(self) -> None: ...
    positions: Incomplete
    def __init__(self, positions: str | list[str], style: str = "side", **properties) -> None: ...
    def add(self, d: DisplayableLike) -> None: ...
    def _clear(self) -> None: ...
    def per_interact(self) -> None: ...
    cwidth: Incomplete
    cheight: Incomplete
    top: Incomplete
    bottom: Incomplete
    left: Incomplete
    right: Incomplete
    offsets: Incomplete
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...

class Alpha(renpy.display.displayable.Displayable):
    start: Incomplete
    end: Incomplete
    time: Incomplete
    child: Incomplete
    repeat: Incomplete
    anim_timebase: Incomplete
    time_warp: Incomplete
    def __init__(
        self,
        start: float,
        end: float,
        time: float,
        child: DisplayableLike | None = None,
        repeat: bool = False,
        bounce: bool = False,
        anim_timebase: bool = False,
        time_warp: Callable[[float], float] | None = None,
        **properties,
    ) -> None: ...
    def visit(self): ...
    def render(self, height, width, st, at): ...

class AdjustTimes(Container):
    start_time: Incomplete
    anim_time: Incomplete
    def __init__(
        self, child: DisplayableLike, start_time: float | None, anim_time: float | None, **properties
    ) -> None: ...
    def adjusted_times(self) -> tuple[float, float]: ...
    offsets: Incomplete
    def render(self, w, h, st, at): ...
    def event(self, ev, x, y, st): ...
    def get_placement(self): ...

class MatchTimes(Container):
    target: Incomplete
    def __init__(self, child: DisplayableLike, target: AdjustTimes, **properties) -> None: ...
    offsets: Incomplete
    def render(self, w: int, h: int, st: float, at: float) -> renpy.display.render.Render: ...
    def get_placement(self): ...

class Tile(Container):
    def __init__(self, child: DisplayableLike, style: str = "tile", **properties) -> None: ...
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...

LiveTile = Tile

class Flatten(Container):
    drawable_resolution: bool
    def __init__(self, child: DisplayableLike, drawable_resolution: bool = True, **properties) -> None: ...
    offsets: Incomplete
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...
    def get_placement(self): ...

class AlphaMask(Container):
    invert: bool
    _duplicatable: bool
    mask: Incomplete
    def __init__(self, child: DisplayableLike, mask: DisplayableLike, invert: bool = False, **properties) -> None: ...
    def _duplicate(self, args: DisplayableArguments | None) -> Self: ...
    def _unique(self) -> None: ...
    def visit(self): ...
    offsets: Incomplete
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...

class NearRect(Container):
    preferred_side: Literal["left", "top", "right", "bottom"]
    invert_offsets: bool
    possible_positions: set[str]
    parent_rect: Incomplete
    focus_rect: Incomplete
    hide_parent_rect: Incomplete
    def __init__(
        self,
        child: DisplayableLike | None = None,
        rect: tuple[float, float, float, float] | None = None,
        focus: str | None = None,
        preferred_side: Literal["left", "top", "right", "bottom", False] = False,
        invert_offsets: bool = False,
        replaces: Self | None = None,
        **properties,
    ) -> None: ...
    def per_interact(self) -> None: ...
    offsets: Incomplete
    def render(self, width: float, height: float, st: float, at: float) -> renpy.display.render.Render: ...
    def event(self, ev, x, y, st): ...
    def _tts(self, raw: bool) -> str: ...

class Layer(AdjustTimes):
    layers: Incomplete
    layer: Incomplete
    _clipping: Incomplete
    def __init__(self, layer: str, **properties) -> None: ...
    start_time: Incomplete
    anim_time: Incomplete
    def add(self, d: DisplayableLike, st: float | None = None, at: float | None = None): ...
    def visit_all(self, callback, seen=None) -> None: ...
    def per_interact(self) -> None: ...
