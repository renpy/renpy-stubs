import renpy
from collections.abc import Generator
from renpy.ast import Node as Node, NodeName as NodeName
from renpy.display.image import ShownImageInfo as ShownImageInfo
from renpy.display.scenelists import SceneLists as SceneLists
from renpy.display.video import Movie as Movie
from renpy.error import TracebackException as TracebackException
from renpy.object import Object as Object
from renpy.types import Unused as Unused
from types import FrameType as FrameType
from typing import Any, Callable, Literal, Sequence, Iterable, overload

il_statements: int
il_time: float

def check_infinite_loop() -> None: ...
def not_infinite_loop(delay: float) -> None: ...

class Delete: ...
class PredictInfo(renpy.object.Object): ...

class NewPredictInfo:
    node: renpy.ast.Node
    images: renpy.display.image.ShownImageInfo
    predict_return_stack: list[Any]
    tlids: list[str | None]

class LineLogEntry:
    filename: str
    line: int
    node_name: NodeName
    abnormal: bool
    def __init__(self, filename: str, line: int, node: Node, abnormal: bool) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def node(self) -> Node: ...

class Context(renpy.object.Object):
    __version__: int
    nosave: list[str]
    next_node: Node | None
    force_checkpoint: bool
    come_from_name: NodeName | None
    come_from_label: str | None
    temporary_attributes: tuple[str, ...] | None
    deferred_translate_identifier: str | None
    predict_return_stack: list[NodeName] | None
    exception_handler: Callable[[renpy.error.TracebackException], bool] | None
    translated: bool
    def __repr__(self) -> str: ...
    abnormal: bool
    last_abnormal: bool
    music: dict[str | int, renpy.audio.audio.MusicContext]
    interacting: bool
    modes: renpy.revertable.RevertableList[str]
    use_modes: bool
    images: renpy.display.image.ShownImageInfo
    init_phase: bool
    defer_rollback: tuple[bool, int] | None
    translate_language: str | None
    translate_identifier: str | None
    say_attributes: tuple[str, ...] | None
    line_log: list[LineLogEntry]
    movie: dict[str, renpy.display.video.Movie]
    abnormal_stack: list[bool]
    alternate_translate_identifier: str | None
    def after_upgrade(self, version: int) -> None: ...
    current: NodeName | None
    call_location_stack: list[NodeName]
    return_stack: list[NodeName]
    dynamic_stack: list[dict[str, Any]]
    rollback: bool
    runtime: float
    info: renpy.revertable.RevertableObject
    seen: bool
    scene_lists: renpy.display.scenelists.SceneLists
    def __init__(self, rollback: bool, context: Context | None = None, clear: bool | list[str] = False) -> None: ...
    def replace_node(self, old: Node, new: Node) -> None: ...
    def make_dynamic(self, names: Iterable[str], context: bool = False) -> None: ...
    def pop_dynamic(self) -> None: ...
    def pop_all_dynamic(self) -> None: ...
    def pop_dynamic_roots(self, roots: dict[str, Any]) -> None: ...
    def goto_label(self, node_name: NodeName) -> None: ...
    def check_stacks(self) -> None: ...
    def handle_exception(self) -> None: ...
    @overload
    def report_traceback(self, name: str, last: Literal[True]) -> None: ...
    @overload
    def report_traceback(self, name: str, last: Literal[False]) -> list[tuple[str, int, str, None]]: ...
    def report_coverage(self, node: Node) -> None: ...
    def come_from(self, name: NodeName, label: str | None) -> None: ...
    translate_interaction: Unused
    def run(self, node: Node | None = None) -> None: ...
    def mark_seen(self) -> None: ...
    def call(self, label: NodeName, return_site: NodeName | None = None) -> Node: ...
    def pop_call(self) -> None: ...
    def lookup_return(self, pop: bool = True) -> Node | None: ...
    def rollback_copy(self) -> Context: ...
    def predict_call(self, label: NodeName, return_site: NodeName) -> Node: ...
    def predict_return(self) -> Node | None: ...
    def predict(self) -> Generator[bool, None, None]: ...
    def seen_current(self, ever: bool) -> bool: ...
    def do_deferred_rollback(self) -> None: ...
    def get_return_stack(self) -> list[NodeName]: ...
    def set_return_stack(self, return_stack: Sequence[NodeName]) -> None: ...

def run_context(top: bool) -> Any: ...
def reset_all_contexts() -> None: ...
