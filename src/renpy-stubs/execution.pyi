import renpy
from _typeshed import Incomplete as Incomplete
from collections.abc import Generator
from renpy.ast import Node as Node
from renpy.display.image import ShownImageInfo as ShownImageInfo
from renpy.error import TracebackException as TracebackException
from renpy.object import Object as Object
from types import FrameType as FrameType
from typing import Any, Callable

il_statements: int
il_time: int

def check_infinite_loop() -> None: ...
def not_infinite_loop(delay) -> None: ...

class Delete: ...
class PredictInfo(renpy.object.Object): ...

class NewPredictInfo:
    node: renpy.ast.Node
    images: renpy.display.image.ShownImageInfo
    predict_return_stack: list[Any]
    tlids: list[str | None]

class LineLogEntry:
    filename: Incomplete
    line: Incomplete
    node_name: Incomplete
    abnormal: Incomplete
    def __init__(self, filename, line, node, abnormal) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    @property
    def node(self): ...

class Context(renpy.object.Object):
    __version__: int
    nosave: Incomplete
    next_node: Incomplete
    force_checkpoint: bool
    come_from_name: Incomplete
    come_from_label: Incomplete
    temporary_attributes: Incomplete
    deferred_translate_identifier: Incomplete
    predict_return_stack: list | None
    exception_handler: Callable[[renpy.error.TracebackException], bool] | None
    translated: bool
    abnormal: bool
    last_abnormal: bool
    music: Incomplete
    interacting: bool
    modes: Incomplete
    use_modes: bool
    images: Incomplete
    init_phase: bool
    defer_rollback: Incomplete
    translate_language: Incomplete
    translate_identifier: Incomplete
    say_attributes: Incomplete
    line_log: Incomplete
    movie: dict[str, renpy.display.video.Movie]
    abnormal_stack: Incomplete
    alternate_translate_identifier: Incomplete
    def after_upgrade(self, version) -> None: ...
    current: Incomplete
    call_location_stack: Incomplete
    return_stack: Incomplete
    dynamic_stack: Incomplete
    rollback: Incomplete
    runtime: int
    info: Incomplete
    seen: bool
    scene_lists: renpy.display.scenelists.SceneLists
    def __init__(self, rollback, context=None, clear: bool = False) -> None: ...
    def replace_node(self, old, new): ...
    def make_dynamic(self, names, context: bool = False) -> None: ...
    def pop_dynamic(self) -> None: ...
    def pop_all_dynamic(self) -> None: ...
    def pop_dynamic_roots(self, roots) -> None: ...
    def goto_label(self, node_name) -> None: ...
    def check_stacks(self) -> None: ...
    def handle_exception(self) -> None: ...
    def report_traceback(self, name: str, last: bool): ...
    def report_coverage(self, node) -> None: ...
    def come_from(self, name, label) -> None: ...
    translate_interaction: Incomplete
    def run(self, node=None) -> None: ...
    def mark_seen(self) -> None: ...
    def call(self, label, return_site=None): ...
    def pop_call(self) -> None: ...
    def lookup_return(self, pop: bool = True): ...
    def rollback_copy(self): ...
    def predict_call(self, label, return_site): ...
    def predict_return(self): ...
    def predict(self) -> Generator[Incomplete]: ...
    def seen_current(self, ever): ...
    def do_deferred_rollback(self) -> None: ...
    def get_return_stack(self): ...
    def set_return_stack(self, return_stack) -> None: ...

def run_context(top): ...
def reset_all_contexts() -> None: ...
