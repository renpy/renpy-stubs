import re
import renpy
from renpy.astsupport import PyExpr as PyExpr, hash32 as hash32
from renpy.atl import RawBlock as RawBlock
from renpy.cslots import IntegerSlot as IntegerSlot, Object as Object, Slot as Slot
from renpy.lexer import SubParse as SubParse
from renpy.object import Sentinel as Sentinel
from renpy.parameter import (
    ArgumentInfo as ArgumentInfo,
    EMPTY_ARGUMENTS as EMPTY_ARGUMENTS,
    EMPTY_PARAMETERS as EMPTY_PARAMETERS,
    Parameter as Parameter,
    ParameterInfo as ParameterInfo,
    Signature as Signature,
    apply_arguments as apply_arguments,
)
from renpy.sl2.slast import SLScreen as SLScreen
from renpy.test.testast import TestCase as TestCase
from renpy.types import Unused as Unused
from typing import Any, Callable, ClassVar, Literal

type NodeLocation = tuple[str, int]
EARLY_CONFIG: set[str]

class PyCode(Object):
    _cslot_linenumbers: bool
    filename: str
    source: str
    location: tuple[Any, ...]
    mode: Literal["eval", "exec", "hide"]
    bytecode: bytes | None
    py: int
    hashcode: int
    def __getstate__(self) -> tuple[int, str, NodeLocation, Literal["eval", "exec", "hide"], int, int, int]: ...
    linenumber: int
    col_offset: int
    def __setstate__(
        self, state: tuple[int, str, NodeLocation, Literal["eval", "exec", "hide"], int, int, int]
    ) -> None: ...
    def __init__(
        self, source: str, loc: tuple[str, int] = ("<none>", 1), mode: Literal["eval", "exec", "hide"] = "exec"
    ) -> None: ...
    _leading_whitespace_re: re.Pattern[str]
    @staticmethod
    def dedent(text: str, col_offset: int) -> tuple[str, int]: ...

DoesNotExtend: renpy.object.Sentinel

class Scry:
    _next: Node | None
    interacts: bool
    say: bool
    menu_with_caption: bool
    who: str | None
    extend_text: str | None | renpy.object.Sentinel
    multiple: int | None
    def __getattr__(self, name: str) -> Any: ...
    def __reduce__(self) -> None: ...
    def next(self) -> Scry | None: ...

type NodeName = "str | tuple[str, int, int] | tuple[Any, ...] | None"
type RollbackType = Literal["normal", "never", "force"]
type SignedInt = int

class Node(Object):
    _cslot_linenumbers: bool
    filename: str
    _name: NodeName
    name_version: int
    name_serial: int
    next: Node | None
    translatable: ClassVar[bool]
    translation_relevant: ClassVar[bool]
    rollback: ClassVar[RollbackType]
    warp: ClassVar[bool]
    @property
    def name(self) -> NodeName: ...
    @name.setter
    def name(self, value: NodeName): ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def statement_start(self) -> Node: ...
    @statement_start.setter
    def statement_start(self, value: Node) -> None: ...
    linenumber: int
    def __init__(self, loc: NodeLocation) -> None: ...
    def diff_info(self) -> tuple[Any, ...]: ...
    def get_children(self, f: Callable[[Node], Any]) -> None: ...
    def execute_init(self) -> None: ...
    def get_init(self) -> int | None: ...
    def chain(self, next: Node | None) -> None: ...
    def replace_next(self, old: Node, new: Node) -> None: ...
    def execute(self) -> None: ...
    def early_execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...
    def restructure(self, callback: Callable[[list["Node"]], Any]): ...
    def get_code(self, dialogue_filter: Callable[[str], str] | None = None) -> str: ...
    def analyze(self) -> None: ...
    def can_warp(self) -> bool: ...
    def get_reachable(self) -> list["Node"]: ...
    def get_translation_strings(self) -> list[tuple[int, str]]: ...

current_statement_name: str

def statement_name(name: str) -> None: ...
def next_node(n: Node | None) -> None: ...
def probably_side_effect_free(expr: str) -> bool: ...
def chain_block(block: list[Node], next: Node | None) -> None: ...
def say_menu_with(expression: str | None, callback: Callable[[Any], Any]) -> None: ...
def eval_who(who: str | None, fast: bool | None = None) -> Any | None: ...

type ImspecType = "\ntuple[tuple[str, ...], str | None, str | None, list[str], str | None, str | None, list[str]] |\ntuple[tuple[str, ...], str | None, str | None, list[str], str | None, str | None] |\ntuple[tuple[str, ...], list[str], str | None]\n"

def predict_imspec(imspec: ImspecType, scene: bool = False, atl: renpy.atl.RawBlock | None = None) -> None: ...
def show_imspec(imspec: ImspecType, atl: renpy.atl.RawBlock | None = None) -> None: ...
def create_store(name: str) -> None: ...

class StoreNamespace:
    pure: bool
    repeat_at_default_time: bool
    store: str
    def __init__(self, store: str) -> None: ...
    def set(self, name: str, value: Any) -> None: ...
    def set_default(self, name: str, value: Any) -> None: ...
    def get(self, name: str) -> Any: ...

def get_namespace(store: str) -> tuple[StoreNamespace, bool]: ...
def redefine(stores: list[str]) -> None: ...
def _reach_any(source: Node, target: Node) -> bool: ...
def get_reachable_nodes(
    entry_nodes: list[Node], node_validator: Callable[[Node, Node], bool] = ..., seen: set[Node] | None = None
) -> list[Node]: ...

class Say(Node):
    who: str | None
    who_fast: bool
    what: str
    with_: str | None
    interact: bool
    attributes: tuple[str, ...] | None
    arguments: ArgumentInfo | None
    temporary_attributes: tuple[str, ...] | None
    rollback: RollbackType
    identifier: str | None
    explicit_identifier: bool
    def diff_info(self) -> tuple[type, str | None, str]: ...
    def __init__(
        self,
        loc: NodeLocation,
        who: str | None,
        what: str,
        with_: str | None,
        interact: bool = True,
        attributes: tuple[str, ...] | None = None,
        arguments: ArgumentInfo | None = None,
        temporary_attributes: tuple[str, ...] | None = None,
        identifier: str | None = None,
    ) -> None: ...
    def get_code(self, dialogue_filter: Callable[[str], str] | None = None) -> str: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...

class Init(Node):
    block: list[Node]
    priority: SignedInt
    def __init__(self, loc: NodeLocation, block: list[Node], priority: SignedInt) -> None: ...
    def get_children(self, f: Callable[[Node], Any]) -> None: ...
    def execute_init(self) -> None: ...
    def get_init(self) -> SignedInt: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def execute(self) -> None: ...
    def restructure(self, callback: Callable[[list[Node]], Any]): ...

class Label(Node):
    translation_relevant: bool
    block: list[Node]
    parameters: ParameterInfo | None
    hide: bool
    name: NodeName
    def __init__(
        self, loc: NodeLocation, name: NodeName, block: list[Node], parameters: ParameterInfo | None, hide: bool = False
    ) -> None: ...
    def diff_info(self) -> tuple[type, NodeName]: ...
    def get_children(self, f: Callable[[Node], Any]) -> None: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def execute(self) -> None: ...
    def restructure(self, callback: Callable[[list[Node]], Any]): ...

class Python(Node):
    code: PyCode
    store: str
    hide: bool
    def __init__(self, loc: NodeLocation, python_code: str, hide: bool = False, store: str = "store") -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def early_execute(self) -> None: ...
    def execute(self) -> None: ...
    def scry(self) -> Scry: ...

class EarlyPython(Node):
    code: PyCode
    store: str
    hide: bool
    def __init__(self, loc: NodeLocation, python_code: str, hide: bool = False, store: str = "store") -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def execute(self) -> None: ...
    def early_execute(self) -> None: ...

class Image(Node):
    imgname: tuple[str, ...]
    code: PyCode | None
    atl: renpy.atl.RawBlock | None
    def __init__(
        self, loc: NodeLocation, name: tuple[str, ...], expr: str | None = None, atl: renpy.atl.RawBlock | None = None
    ) -> None: ...
    def diff_info(self) -> tuple[type, tuple[str, ...]]: ...
    def execute(self) -> None: ...
    def analyze(self) -> None: ...

class Transform(Node):
    varname: str
    atl: renpy.atl.RawBlock
    parameters: ParameterInfo | None
    store: str
    default_parameters = EMPTY_PARAMETERS
    def __init__(
        self, loc: NodeLocation, store: str, name: str, atl: renpy.atl.RawBlock, parameters: ParameterInfo | None = ...
    ) -> None: ...
    def diff_info(self) -> tuple[type, str, str]: ...
    def early_execute(self) -> None: ...
    def execute(self) -> None: ...
    def analyze(self) -> None: ...

class Show(Node):
    imspec: ImspecType
    atl: renpy.atl.RawBlock | None
    warp: bool
    def __init__(self, loc: NodeLocation, imspec: ImspecType, atl: renpy.atl.RawBlock | None = None) -> None: ...
    def diff_info(self) -> tuple[type, tuple[str, ...]]: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def analyze(self) -> None: ...

class ShowLayer(Node):
    warp: bool
    at_list: list[str]
    atl: renpy.atl.RawBlock | None
    layer: str
    def __init__(self, loc: NodeLocation, layer: str, at_list: list[str], atl: renpy.atl.RawBlock | None) -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def analyze(self) -> None: ...

class Camera(Node):
    warp: bool
    at_list: list[str]
    atl: renpy.atl.RawBlock | None
    layer: str
    def __init__(self, loc: NodeLocation, layer: str, at_list: list[str], atl: renpy.atl.RawBlock | None) -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def analyze(self) -> None: ...

class Scene(Node):
    imspec: ImspecType
    atl: renpy.atl.RawBlock | None
    layer: str | None
    warp: bool
    def __init__(
        self, loc: NodeLocation, imgspec: ImspecType, layer: str | None, atl: renpy.atl.RawBlock | None = None
    ) -> None: ...
    def diff_info(self) -> tuple[type, tuple[str, ...] | None]: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def analyze(self) -> None: ...

class Hide(Node):
    warp: bool
    imspec: ImspecType
    def __init__(self, loc: NodeLocation, imgspec: ImspecType) -> None: ...
    def diff_info(self) -> tuple[type, tuple[str, ...]]: ...
    def predict(self) -> list[Node | None]: ...
    def execute(self) -> None: ...

class With(Node):
    expr: str
    paired: str | None
    def __init__(self, loc: NodeLocation, expr: str, paired: str | None = None) -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...

class Call(Node):
    label: str
    arguments: ArgumentInfo | None
    expression: bool
    global_label: str
    def __init__(
        self, loc: NodeLocation, label: str, expression: bool, arguments: ArgumentInfo | None, global_label: str = ""
    ) -> None: ...
    def diff_info(self) -> tuple[type, str, bool]: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...
    def get_reachable(self) -> list[Node]: ...

class Return(Node):
    expression: str | None
    def __init__(self, loc: NodeLocation, expression: str | None) -> None: ...
    def diff_info(self) -> tuple[type]: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...

class Menu(Node):
    translation_relevant: bool
    items: list[tuple[str, str, list[Node] | None]]
    statement_start: Node
    set: str | None
    with_: str | None
    has_caption: bool
    arguments: ArgumentInfo | None
    item_arguments: list[ArgumentInfo | None] | None
    rollback: RollbackType
    def __init__(
        self,
        loc: NodeLocation,
        items: list[tuple[str, str, list[Node] | None]],
        set: str | None,
        with_: str | None,
        has_caption: bool,
        arguments: ArgumentInfo | None,
        item_arguments: list[ArgumentInfo | None] | None,
    ) -> None: ...
    def diff_info(self) -> tuple[type]: ...
    def get_children(self, f: Callable[[Node], Any]) -> None: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def replace_next(self, old: Node, new: Node) -> None: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...
    def restructure(self, callback: Callable[[list[Node]], Any]): ...
    def get_reachable(self) -> list[Node]: ...
    def get_translation_strings(self) -> list[tuple[int, str]]: ...

class Jump(Node):
    target: str
    expression: bool
    global_label: str
    def __init__(self, loc: NodeLocation, target: str, expression: bool, global_label: str = "") -> None: ...
    def diff_info(self) -> tuple[type, str, bool]: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...
    def get_reachable(self) -> list[Node]: ...

class Pass(Node):
    def diff_info(self) -> tuple[type]: ...
    def execute(self) -> None: ...

class While(Node):
    condition: str
    block: list[Node]
    def __init__(self, loc: NodeLocation, condition: str, block: list[Node]) -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def get_children(self, f: Callable[[Node], Any]) -> None: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def replace_next(self, old: Node, new: Node) -> None: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...
    def restructure(self, callback: Callable[[list[Node]], Any]): ...
    def get_reachable(self) -> list[Node]: ...

class If(Node):
    entries: list[tuple[str, list[Node]]]
    def __init__(self, loc: NodeLocation, entries: list[tuple[str, list[Node]]]) -> None: ...
    def diff_info(self) -> tuple[type]: ...
    def get_children(self, f: Callable[[Node], Any]) -> None: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def replace_next(self, old: Node, new: Node) -> None: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...
    def restructure(self, callback: Callable[[list[Node]], Any]): ...
    def get_reachable(self) -> list[Node]: ...

class UserStatement(Node):
    line: str
    parsed: Any
    block: list[Any]
    translatable: bool
    code_block: list[Node] | None
    translation_relevant: bool
    rollback: RollbackType
    subparses: list["renpy.lexer.SubParse"]
    atl: renpy.atl.RawBlock | None
    init_priority: SignedInt | None
    init_offset: SignedInt | None
    name: str
    def __init__(self, loc: NodeLocation, line: str, block: list[Node], parsed: Any) -> None: ...
    def __repr__(self) -> str: ...
    def get_children(self, f: Callable[[Node], Any]) -> None: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def replace_next(self, old: Node, new: Node) -> None: ...
    def restructure(self, callback: Callable[[list[Node]], Any]): ...
    def diff_info(self) -> tuple[type, str]: ...
    def call(self, method: str, *args, **kwargs) -> Any | None: ...
    def execute_init(self) -> None: ...
    def get_init(self) -> SignedInt | None: ...
    def execute(self) -> None: ...
    def execute_default(self, start) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def get_name(self) -> str: ...
    def get_next(self) -> Node | None: ...
    def scry(self) -> Scry: ...
    def get_code(self, dialogue_filter: Callable[[str], str] | None = None) -> str: ...
    def can_warp(self) -> bool: ...
    def reachable(self, is_reachable: bool) -> set[NodeName | Literal[True] | renpy.lexer.SubParse | None]: ...
    def get_reachable(self) -> list[Node]: ...
    def analyze(self) -> None: ...
    def get_translation_strings(self) -> list[tuple[int, str]]: ...

class PostUserStatement(Node):
    parent: UserStatement
    name: str | None
    def __init__(self, loc: NodeLocation, parent: UserStatement) -> None: ...
    def __repr__(self) -> str: ...
    def diff_info(self) -> tuple[type, str]: ...
    def execute(self) -> None: ...

define_statements: list["Define"]

class Define(Node):
    varname: str
    code: PyCode
    store: str
    operator: str
    index: PyCode | None
    def __init__(
        self, loc: NodeLocation, store: str, name: str, index: str | None, operator: str, expr: str
    ) -> None: ...
    def diff_info(self) -> tuple[type, str, str]: ...
    def early_execute(self) -> None: ...
    def execute(self) -> None: ...
    def redefine(self, stores: list[str]): ...
    def set(self) -> None: ...

default_statements: list[Default | UserStatement]

class Default(Node):
    varname: str
    code: PyCode
    store: str
    def __init__(self, loc: NodeLocation, store: str, name: str, expr: str) -> None: ...
    def diff_info(self) -> tuple[type, str, str]: ...
    def early_execute(self) -> None: ...
    def execute(self) -> None: ...
    def execute_default(self, start) -> None: ...
    def report_traceback(self, name: str, last: Unused) -> list[tuple[str, int, str, None]]: ...

class Screen(Node):
    screen: renpy.sl2.slast.SLScreen
    def __init__(self, loc: NodeLocation, screen: renpy.sl2.slast.SLScreen) -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def execute(self) -> None: ...

class Style(Node):
    style_name: str
    parent: str | None
    properties: dict[str, str]
    clear: bool
    take: str | None
    delattr: list[str]
    variant: str | None
    def __init__(self, loc: NodeLocation, name: str) -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def apply(self) -> None: ...
    def execute(self) -> None: ...

class Testcase(Node):
    test: renpy.test.testast.TestCase
    name: str
    def __init__(self, loc: NodeLocation, test: renpy.test.testast.TestCase) -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def execute(self) -> None: ...

class RPY(Node):
    rest: tuple[str, ...]
    def __init__(self, loc: NodeLocation, rest: tuple[str, ...]) -> None: ...
    def diff_info(self): ...
    def execute(self) -> None: ...
    def get_code(self, dialogue_filter: Callable[[str], str] | None = None) -> str: ...

class Translate(Node):
    rollback: str
    translation_relevant: bool
    identifier: str
    alternate: str | None
    language: str | None
    block: list[Node]
    after: Node | None
    def __init__(
        self, loc: NodeLocation, identifier: str, language: str | None, block: list[Node], alternate: str | None = None
    ) -> None: ...
    def diff_info(self) -> tuple[type, str, str | None]: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def replace_next(self, old: Node, new: Node) -> None: ...
    def lookup(self) -> Node: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...
    def get_children(self, f: Callable[[Node], Any]) -> None: ...
    def restructure(self, callback: Callable[[list[Node]], Any]): ...
    def get_reachable(self) -> list[Node]: ...

class TranslateSay(Say):
    translatable: bool
    translation_relevant: bool
    alternate: str | None
    language: str | None
    @property
    def after(self) -> Node | None: ...
    @property
    def block(self) -> list[Node]: ...
    identifier: str | None
    def __init__(
        self,
        loc: NodeLocation,
        who: str | None,
        what: str,
        with_: str | None = None,
        interact: bool = True,
        attributes: tuple[str, ...] | None = None,
        arguments: ArgumentInfo | None = None,
        temporary_attributes: tuple[str, ...] | None = None,
        identifier: str | None = None,
        language: str | None = None,
        alternate: str | None = None,
    ) -> None: ...
    def diff_info(self) -> tuple[type, str | None, str | None]: ...
    def chain(self, next: Node | None) -> None: ...
    def replace_next(self, old: Node, new: Node) -> None: ...
    def lookup(self) -> Node: ...
    def execute(self) -> None: ...
    def predict(self) -> list[Node | None]: ...
    def scry(self) -> Scry: ...
    def get_reachable(self) -> list[Node]: ...

class EndTranslate(Node):
    rollback: str
    def diff_info(self): ...
    def execute(self) -> None: ...

class TranslateString(Node):
    translation_relevant: bool
    language: str
    old: str
    new: str
    newloc: tuple[str, int]
    def __init__(self, loc: NodeLocation, language: str, old: str, new: str, newloc: tuple[str, int]) -> None: ...
    def diff_info(self) -> tuple[type]: ...
    def execute(self) -> None: ...

class TranslatePython(Node):
    translation_relevant: bool
    language: str
    code: PyCode
    def __init__(self, loc: NodeLocation, language: str, python_code: str) -> None: ...
    def diff_info(self) -> tuple[type, str]: ...
    def execute(self) -> None: ...

class TranslateBlock(Node):
    translation_relevant: bool
    block: list[Node]
    language: str | None
    def __init__(self, loc: NodeLocation, language: str | None, block: list[Node]) -> None: ...
    def get_children(self, f: Callable[[Node], Any]) -> None: ...
    next: Node | None
    def chain(self, next: Node | None) -> None: ...
    def execute(self) -> None: ...
    def restructure(self, callback: Callable[[list[Node]], Any]): ...

class TranslateEarlyBlock(TranslateBlock): ...
