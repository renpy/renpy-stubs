import ast
import renpy
import weakref
from renpy.ast import NodeLocation as NodeLocation
from renpy.compat.pickle import dumps as dumps, loads as loads
from renpy.display.displayable import Displayable as Displayable
from renpy.display.layout import Fixed as Fixed
from renpy.display.transform import ATLTransform as ATLTransform, Transform as Transform
from renpy.pyanalysis import (
    Analysis as Analysis,
    GLOBAL_CONST as GLOBAL_CONST,
    LOCAL_CONST as LOCAL_CONST,
    NOT_CONST as NOT_CONST,
    ccache as ccache,
)
from renpy.python import py_eval_bytecode as py_eval_bytecode
from renpy.types import Unused as Unused
from renpy.ui import Addable as Addable
from types import CodeType
from typing import Any, Callable, Self

type CacheDict = dict[int, SLCache | dict[str, Any]]
type UsesScopeList = list[tuple[Displayable | None, dict[str, Any], dict[str, Any] | None]]
serial: int
use_expression: renpy.object.Sentinel
filename: str
profile_log: renpy.log.LogFile
STICKY_PROPERTIES: list[str]

def compile_expr(loc: NodeLocation, node: ast.AST) -> Any: ...

class SLContext(renpy.ui.Addable):
    scope: dict[str, Any]
    root_scope: dict[str, Any]
    globals: dict[str, Any]
    children: list[Displayable]
    keywords: dict[str, Any]
    style_prefix: str | None
    new_cache: dict
    old_cache: dict
    miss_cache: dict
    use_index: dict[int, int]
    uses_scope: UsesScopeList | None
    widgets: Unused | None
    debug: bool
    predicting: bool
    updating: bool
    predicted: set[int]
    showif: bool | None
    fail: bool
    parent: weakref.ReferenceType | None
    transclude: SLBlock | None
    unlikely: bool
    new_use_cache: dict[int, dict[str, Any]]
    old_use_cache: dict[int, dict[str, Any]]
    sticky: dict[str, Any]
    same_version: bool
    def __init__(self, parent: SLContext | None = None) -> None: ...
    def add(self, d: Displayable, key: str | None) -> None: ...
    def close(self, d: Displayable | None) -> None: ...

class SLNode:
    constant = GLOBAL_CONST
    has_keyword: bool
    last_keyword: bool
    serial: int
    location: NodeLocation
    def __init__(self, loc: NodeLocation) -> None: ...
    def instantiate(self, transclude: int) -> Self: ...
    def copy(self, transclude: int) -> Self: ...
    def report_traceback(self, name: str, last: bool) -> list[tuple[str, int, str, str | None]] | None: ...
    def analyze(self, analysis: Analysis) -> None: ...
    def prepare(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def keywords(self, context: SLContext) -> None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def debug_line(self) -> None: ...
    def used_screens(self, callback: Callable[[str], None]) -> None: ...
    def has_transclude(self) -> bool: ...
    def has_python(self) -> bool: ...
    def dump_const(self, prefix: str) -> None: ...
    def dc(self, prefix: str, text: str, *args) -> None: ...

def analyze_keywords(node: SLBlock, analysis: Analysis, conditional: int = ...) -> int: ...

NotGiven: renpy.object.Sentinel

class SLBlock(SLNode):
    atl_transform: renpy.atl.RawBlock | None
    transform: renpy.display.transform.ATLTransform | None
    variable: str | None
    keyword: list[tuple[str, str]]
    children: list[SLNode]
    def __init__(self, loc: NodeLocation) -> None: ...
    def instantiate(self, transclude: int) -> Self: ...
    def copy(self, transclude: int) -> Self: ...
    def analyze(self, analysis: Analysis) -> None: ...
    constant: int
    keyword_values: dict[str, Any] | None
    keyword_exprs: CodeType | None
    has_keyword: bool
    keyword_children: list[SLNode]
    last_keyword: bool
    def prepare(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def keywords(self, context: SLContext) -> None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def used_screens(self, callback: Callable[[str], None]) -> None: ...
    def has_transclude(self) -> bool: ...
    def has_python(self) -> bool: ...
    def has_noncondition_child(self) -> bool: ...
    def keyword_exist(self, name: str) -> bool: ...
    def dump_const(self, prefix: str) -> None: ...

list_or_tuple: tuple[type, ...]

class SLCache:
    displayable: Displayable | None
    positional: list[str] | None
    keywords: dict[str, Any] | None
    children: list[Displayable] | None
    outer_transform: Transform | None
    inner_transform: Transform | None
    raw_transform: Transform | list[Transform] | None
    imagemap: renpy.ui.Imagemap | None
    constant: int | None
    constant_uses_scope: UsesScopeList
    constant_widgets: Unused
    copy_on_change: bool
    old_showif: renpy.sl2.sldisplayables.ShowIf | None
    transclude: SLBlock | None
    style_prefix: str | None
    def __init__(self) -> None: ...

NO_DISPLAYABLE: renpy.display.layout.Null

class SLDisplayable(SLBlock):
    hotspot: bool
    variable: str | None
    name: str
    unique: bool
    local_constant: list[renpy.pyanalysis.DeltaSet]
    displayable: Callable[..., Displayable]
    scope: bool
    child_or_fixed: bool
    style: str | None
    pass_context: bool
    imagemap: bool
    replaces: bool
    default_keywords: dict[str, Any]
    positional: list[str]
    def __init__(
        self,
        loc: NodeLocation,
        displayable: Callable[..., Displayable],
        scope: bool = False,
        child_or_fixed: bool = False,
        style: str | None = None,
        text_style: str | None = None,
        pass_context: bool = False,
        imagemap: bool = False,
        replaces: bool = False,
        default_keywords: dict[str, Any] = {},
        hotspot: bool = False,
        variable: str | None = None,
        name: str = "",
        unique: bool = True,
    ) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    constant: int
    def analyze(self, analysis: Analysis) -> None: ...
    positional_values: list[Any] | None
    positional_exprs: CodeType | None
    has_keyword: bool
    def prepare(self, analysis: Analysis) -> None: ...
    def keywords(self, context: SLContext) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def wrap_in_showif(self, d: Displayable, context: SLContext, cache: SLCache) -> renpy.sl2.sldisplayables.ShowIf: ...
    def report_arguments(
        self,
        cache: SLCache,
        positional: list[str],
        keywords: dict[str, Any],
        transform: Transform | list[Transform] | None,
    ) -> None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def dump_const(self, prefix: str) -> None: ...

class SLIf(SLNode):
    entries: list[tuple[str, SLBlock]]
    def __init__(self, loc: NodeLocation) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def analyze(self, analysis: Analysis) -> None: ...
    prepared_entries: list[tuple[CodeType | None, SLBlock, bool | int]]
    constant: int
    def prepare(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def execute_predicting(self, context: SLContext) -> None: ...
    def keywords(self, context: SLContext) -> None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def used_screens(self, callback: Callable[[str], None]) -> None: ...
    def has_transclude(self) -> bool: ...
    def has_python(self) -> bool: ...
    def keyword_exist(self, name: str) -> bool: ...
    def dump_const(self, prefix: str) -> None: ...

class SLShowIf(SLNode):
    entries: list[tuple[str, SLBlock]]
    def __init__(self, loc: NodeLocation) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def analyze(self, analysis: Analysis) -> None: ...
    prepared_entries: list[tuple[CodeType | None, SLBlock]]
    constant: int
    last_keyword: bool
    def prepare(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def used_screens(self, callback: Callable[[str], None]) -> None: ...
    def has_transclude(self) -> bool: ...
    def has_python(self) -> bool: ...
    def dump_const(self, prefix: str) -> None: ...

class SLFor(SLBlock):
    index_expression: str | None
    variable: str
    expression: str
    def __init__(self, loc: NodeLocation, variable: str, expression: str, index_expression: str | None) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def analyze(self, analysis: Analysis) -> None: ...
    expression_value: list[Any] | None
    expression_expr: CodeType | None
    constant: int
    last_keyword: bool
    def prepare(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def keywords(self, context: SLContext) -> None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def dump_const(self, prefix: str) -> None: ...

class SLForException(Exception): ...
class SLBreakException(SLForException): ...
class SLContinueException(SLForException): ...

class SLBreak(SLNode):
    def analyze(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def dump_const(self, prefix: str) -> None: ...

class SLContinue(SLNode):
    def analyze(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def dump_const(self, prefix: str) -> None: ...

class SLPython(SLNode):
    code: renpy.ast.PyCode
    def __init__(self, loc: NodeLocation, code: renpy.ast.PyCode) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def analyze(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    constant: int
    last_keyword: bool
    def prepare(self, analysis: Analysis) -> None: ...
    def has_python(self) -> bool: ...
    def dump_const(self, prefix: str) -> None: ...

class SLPass(SLNode):
    def execute(self, context: SLContext) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def dump_const(self, prefix: str) -> None: ...

class SLDefault(SLNode):
    variable: str | None
    expression: renpy.ast.PyExpr
    def __init__(self, loc: NodeLocation, variable: str | None, expression: renpy.ast.PyExpr) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def analyze(self, analysis: Analysis) -> None: ...
    expr: CodeType
    constant: int
    last_keyword: bool
    def prepare(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def has_python(self) -> bool: ...
    def dump_const(self, prefix: str) -> None: ...

class SLUse(SLNode):
    id: str | None
    block: SLBlock | None
    variable: str | None
    target: renpy.ast.PyExpr | str
    ast: SLScreen | None
    args: renpy.parameter.ArgumentInfo | None
    def __init__(
        self,
        loc: NodeLocation,
        target: renpy.ast.PyExpr | str,
        args: renpy.parameter.ArgumentInfo | None,
        id_expr: str | None,
        block: SLBlock | None,
        variable: str | None,
    ) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    last_keyword: bool
    constant: int
    def analyze(self, analysis: Analysis) -> None: ...
    def prepare(self, analysis: Analysis) -> None: ...
    def execute_use_screen(self, context: SLContext) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def used_screens(self, callback: Callable[[str], None]) -> None: ...
    def has_transclude(self) -> bool: ...
    def dump_const(self, prefix: str) -> None: ...

class SLTransclude(SLNode):
    def __init__(self, loc: NodeLocation) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def execute(self, context: SLContext) -> None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def has_transclude(self) -> bool: ...
    def dump_const(self, prefix: str) -> None: ...

class SLCustomUse(SLNode):
    variable: str | None
    target: str
    ast: SLScreen | None
    positional: list[str]
    block: SLBlock
    def __init__(
        self, loc: NodeLocation, target: str, positional: list[str], block: SLBlock, variable: str | None
    ) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    last_keyword: bool
    def analyze(self, analysis: Analysis) -> None: ...
    constant: int
    def prepare(self, analysis: Analysis) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def used_screens(self, callback: Callable[[str], None]) -> None: ...
    def has_transclude(self) -> bool: ...
    def dump_const(self, prefix: str) -> None: ...

class SLScreen(SLBlock):
    version: int
    const_ast: SLScreen | None
    not_const_ast: SLScreen | None
    analysis: Analysis | None
    layer: str
    sensitive: str
    roll_forward: str
    docstring: str | None
    name: str | None
    modal: str
    zorder: str
    tag: str | None
    variant: str
    predict: str
    parameters: renpy.parameter.Signature | None
    prepared: bool
    def __init__(self, loc: NodeLocation) -> None: ...
    def copy(self, transclude: int) -> Self: ...
    def define(self, location: NodeLocation) -> None: ...
    def analyze(self, analysis: Analysis) -> None: ...
    def analyze_screen(self) -> None: ...
    def unprepare_screen(self) -> None: ...
    def prepare_screen(self) -> None: ...
    def execute(self, context: SLContext) -> None: ...
    def report_traceback(self, name: str, last: bool) -> list[tuple[str, int, str, str | None]] | None: ...
    def copy_on_change(self, cache: CacheDict) -> None: ...
    def __call__(self, *args, **kwargs) -> None: ...

class ScreenCache:
    version: int
    const_analyzed: dict[tuple[str, str, NodeLocation], SLScreen]
    not_const_analyzed: dict[tuple[str, str, NodeLocation], SLScreen]
    updated: bool
    def __init__(self) -> None: ...

scache: ScreenCache
CACHE_FILENAME: str

def load_cache() -> None: ...
def save_cache() -> None: ...
