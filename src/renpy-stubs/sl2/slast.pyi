import renpy
from _typeshed import Incomplete as Incomplete
from renpy.compat.pickle import dumps as dumps, loads as loads
from renpy.display.displayable import Displayable as Displayable
from renpy.display.layout import Fixed as Fixed
from renpy.display.transform import ATLTransform as ATLTransform, Transform as Transform
from renpy.pyanalysis import (
    Analysis as Analysis,
    GLOBAL_CONST as GLOBAL_CONST,
    LOCAL_CONST as LOCAL_CONST,
    NOT_CONST as NOT_CONST,
    ccache as ccache,
)
from renpy.python import py_eval_bytecode as py_eval_bytecode
from renpy.ui import Addable as Addable

serial: Incomplete
use_expression: Incomplete
filename: str
profile_log: Incomplete
STICKY_PROPERTIES: Incomplete

def compile_expr(loc: Incomplete, node: Incomplete) -> Incomplete: ...

class SLContext(renpy.ui.Addable):
    scope: dict[str, Any]
    root_scope: Incomplete
    globals: dict[str, Any]
    children: list[renpy.display.displayable.Displayable]
    keywords: dict[str, Any] | None
    style_prefix: Incomplete
    new_cache: dict[Any, Any]
    old_cache: dict[Any, Any]
    miss_cache: dict[Any, Any]
    use_index: Incomplete
    uses_scope: list[Any] | None
    widgets: dict[str, Any] | None
    debug: bool
    predicting: bool
    updating: bool
    predicted: set[Any]
    showif: bool | None
    fail: bool
    parent: Any
    transclude: Any
    unlikely: bool
    new_use_cache: dict[Any, Any]
    old_use_cache: dict[Any, Any]
    sticky: dict[str, Any]
    same_version: bool
    def __init__(self, parent: Incomplete = None) -> None: ...
    def add(self, d: Incomplete, key: Incomplete) -> None: ...
    def close(self, d: Incomplete) -> None: ...

class SLNode:
    constant = GLOBAL_CONST
    has_keyword: bool
    last_keyword: bool
    serial: Incomplete
    location: Incomplete
    def __init__(self, loc: Incomplete) -> None: ...
    def instantiate(self, transclude: Incomplete) -> Incomplete: ...
    def copy(self, transclude: Incomplete) -> None: ...
    def report_traceback(self, name: Incomplete, last: Incomplete) -> Incomplete: ...
    def analyze(self, analysis: Incomplete) -> None: ...
    def prepare(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def keywords(self, context: Incomplete) -> None: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def debug_line(self) -> None: ...
    def used_screens(self, callback: Incomplete) -> None: ...
    def has_transclude(self) -> Incomplete: ...
    def has_python(self) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...
    def dc(self, prefix: Incomplete, text: Incomplete, *args: Incomplete) -> None: ...

def analyze_keywords(node: Incomplete, analysis: Incomplete, conditional: Incomplete = ...) -> Incomplete: ...

NotGiven: Incomplete

class SLBlock(SLNode):
    atl_transform: Incomplete
    transform: Incomplete
    variable: str | None
    keyword: Incomplete
    children: Incomplete
    def __init__(self, loc: Incomplete) -> None: ...
    def instantiate(self, transclude: Incomplete) -> Incomplete: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def analyze(self, analysis: Incomplete) -> None: ...
    constant: Incomplete
    keyword_values: Incomplete
    keyword_exprs: Incomplete
    has_keyword: Incomplete
    keyword_children: Incomplete
    last_keyword: bool
    def prepare(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def keywords(self, context: Incomplete) -> None: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def used_screens(self, callback: Incomplete) -> None: ...
    def has_transclude(self) -> Incomplete: ...
    def has_python(self) -> Incomplete: ...
    def has_noncondition_child(self) -> Incomplete: ...
    def keyword_exist(self, name: Incomplete) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

list_or_tuple: Incomplete

class SLCache:
    displayable: renpy.display.displayable.Displayable | None
    positional: Any
    keywords: dict[str, Any] | None
    children: list[renpy.display.displayable.Displayable] | None
    outer_transform: Any | None
    inner_transform: Any | None
    raw_transform: Any | None
    imagemap: Any | None
    constant: Any | None
    constant_uses_scope: list[Any] | None
    constant_widgets: dict[Any, Any]
    copy_on_change: bool
    old_showif: Any
    transclude: Any
    style_prefix: str | None
    def __init__(self) -> None: ...

NO_DISPLAYABLE: Incomplete

class SLDisplayable(SLBlock):
    hotspot: bool
    variable: Incomplete
    name: str
    unique: bool
    local_constant: Incomplete
    displayable: Incomplete
    scope: Incomplete
    child_or_fixed: Incomplete
    style: Incomplete
    pass_context: Incomplete
    imagemap: Incomplete
    replaces: Incomplete
    default_keywords: Incomplete
    positional: Incomplete
    def __init__(
        self,
        loc: Incomplete,
        displayable: Incomplete,
        scope: bool = False,
        child_or_fixed: bool = False,
        style: Incomplete = None,
        text_style: Incomplete = None,
        pass_context: bool = False,
        imagemap: bool = False,
        replaces: bool = False,
        default_keywords: Incomplete = {},
        hotspot: bool = False,
        variable: Incomplete = None,
        name: str = "",
        unique: bool = True,
    ) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    constant: Incomplete
    def analyze(self, analysis: Incomplete) -> None: ...
    positional_values: Incomplete
    positional_exprs: Incomplete
    has_keyword: bool
    def prepare(self, analysis: Incomplete) -> None: ...
    def keywords(self, context: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def wrap_in_showif(self, d: Incomplete, context: Incomplete, cache: Incomplete) -> Incomplete: ...
    def report_arguments(
        self, cache: Incomplete, positional: Incomplete, keywords: Incomplete, transform: Incomplete
    ) -> None: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLIf(SLNode):
    entries: Incomplete
    def __init__(self, loc: Incomplete) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def analyze(self, analysis: Incomplete) -> None: ...
    prepared_entries: Incomplete
    constant: Incomplete
    def prepare(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def execute_predicting(self, context: Incomplete) -> None: ...
    def keywords(self, context: Incomplete) -> None: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def used_screens(self, callback: Incomplete) -> None: ...
    def has_transclude(self) -> Incomplete: ...
    def has_python(self) -> Incomplete: ...
    def keyword_exist(self, name: Incomplete) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLShowIf(SLNode):
    entries: Incomplete
    def __init__(self, loc: Incomplete) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def analyze(self, analysis: Incomplete) -> None: ...
    prepared_entries: Incomplete
    constant: Incomplete
    last_keyword: bool
    def prepare(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def used_screens(self, callback: Incomplete) -> None: ...
    def has_transclude(self) -> Incomplete: ...
    def has_python(self) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLFor(SLBlock):
    index_expression: Incomplete
    variable: Incomplete
    expression: Incomplete
    def __init__(
        self, loc: Incomplete, variable: Incomplete, expression: Incomplete, index_expression: Incomplete
    ) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def analyze(self, analysis: Incomplete) -> None: ...
    expression_value: Incomplete
    expression_expr: Incomplete
    constant: Incomplete
    last_keyword: bool
    def prepare(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def keywords(self, context: Incomplete) -> None: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLForException(Exception): ...
class SLBreakException(SLForException): ...
class SLContinueException(SLForException): ...

class SLBreak(SLNode):
    def analyze(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLContinue(SLNode):
    def analyze(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLPython(SLNode):
    code: Incomplete
    def __init__(self, loc: Incomplete, code: Incomplete) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def analyze(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    constant: Incomplete
    last_keyword: bool
    def prepare(self, analysis: Incomplete) -> None: ...
    def has_python(self) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLPass(SLNode):
    def execute(self, context: Incomplete) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLDefault(SLNode):
    variable: Incomplete
    expression: Incomplete
    def __init__(self, loc: Incomplete, variable: Incomplete, expression: Incomplete) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def analyze(self, analysis: Incomplete) -> None: ...
    expr: Incomplete
    constant: Incomplete
    last_keyword: bool
    def prepare(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def has_python(self) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLUse(SLNode):
    id: Incomplete
    block: Incomplete
    variable: Incomplete
    target: Incomplete
    ast: Incomplete
    args: Incomplete
    def __init__(
        self,
        loc: Incomplete,
        target: Incomplete,
        args: Incomplete,
        id_expr: Incomplete,
        block: Incomplete,
        variable: Incomplete,
    ) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    last_keyword: bool
    constant: Incomplete
    def analyze(self, analysis: Incomplete) -> None: ...
    def prepare(self, analysis: Incomplete) -> None: ...
    def execute_use_screen(self, context: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def used_screens(self, callback: Incomplete) -> None: ...
    def has_transclude(self) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLTransclude(SLNode):
    def __init__(self, loc: Incomplete) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def execute(self, context: Incomplete) -> None: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def has_transclude(self) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLCustomUse(SLNode):
    variable: Incomplete
    target: Incomplete
    ast: Incomplete
    positional: Incomplete
    block: Incomplete
    def __init__(
        self, loc: Incomplete, target: Incomplete, positional: Incomplete, block: Incomplete, variable: Incomplete
    ) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    last_keyword: bool
    def analyze(self, analysis: Incomplete) -> None: ...
    constant: Incomplete
    def prepare(self, analysis: Incomplete) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def used_screens(self, callback: Incomplete) -> None: ...
    def has_transclude(self) -> Incomplete: ...
    def dump_const(self, prefix: Incomplete) -> None: ...

class SLScreen(SLBlock):
    version: int
    const_ast: Incomplete
    not_const_ast: Incomplete
    analysis: Incomplete
    layer: str
    sensitive: str
    roll_forward: str
    docstring: Incomplete
    name: str | None
    modal: str
    zorder: str
    tag: Incomplete
    variant: str
    predict: str
    parameters: Incomplete
    prepared: bool
    def __init__(self, loc: Incomplete) -> None: ...
    def copy(self, transclude: Incomplete) -> Incomplete: ...
    def define(self, location: Incomplete) -> None: ...
    def analyze(self, analysis: Incomplete) -> None: ...
    def analyze_screen(self) -> None: ...
    def unprepare_screen(self) -> None: ...
    def prepare_screen(self) -> None: ...
    def execute(self, context: Incomplete) -> None: ...
    def report_traceback(self, name: Incomplete, last: Incomplete) -> Incomplete: ...
    def copy_on_change(self, cache: Incomplete) -> None: ...
    def __call__(self, *args, **kwargs) -> Incomplete: ...

class ScreenCache:
    version: int
    const_analyzed: Incomplete
    not_const_analyzed: Incomplete
    updated: bool
    def __init__(self) -> None: ...

scache: Incomplete
CACHE_FILENAME: str

def load_cache() -> None: ...
def save_cache() -> None: ...
